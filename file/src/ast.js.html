<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/ast.js | esast API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/mason-lang/esast" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Loc.js~Loc.html">Loc</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Loc.js~Pos.html">Pos</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~ArrayExpression.html">ArrayExpression</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~ArrayPattern.html">ArrayPattern</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~ArrowFunctionExpression.html">ArrowFunctionExpression</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~AssignmentExpression.html">AssignmentExpression</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~AssignmentProperty.html">AssignmentProperty</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~BinaryExpression.html">BinaryExpression</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~BlockStatement.html">BlockStatement</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~BreakStatement.html">BreakStatement</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~CallExpression.html">CallExpression</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~CatchClause.html">CatchClause</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~Class.html">Class</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~ClassBody.html">ClassBody</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~ClassDeclaration.html">ClassDeclaration</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~ClassExpression.html">ClassExpression</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~ConditionalExpression.html">ConditionalExpression</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~ContinueStatement.html">ContinueStatement</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~DebuggerStatement.html">DebuggerStatement</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~Declaration.html">Declaration</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~DoWhileStatement.html">DoWhileStatement</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~EmptyStatement.html">EmptyStatement</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~ExportAllDeclaration.html">ExportAllDeclaration</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~ExportDefaultDeclaration.html">ExportDefaultDeclaration</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~ExportNamedDeclaration.html">ExportNamedDeclaration</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~ExportSpecifier.html">ExportSpecifier</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~Expression.html">Expression</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~ExpressionStatement.html">ExpressionStatement</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~ForInStatement.html">ForInStatement</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~ForOfStatement.html">ForOfStatement</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~ForStatement.html">ForStatement</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~FunctionAbstract.html">FunctionAbstract</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~FunctionDeclaration.html">FunctionDeclaration</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~FunctionExpression.html">FunctionExpression</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~FunctionNonArrow.html">FunctionNonArrow</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~Identifier.html">Identifier</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~IfStatement.html">IfStatement</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~ImportDeclaration.html">ImportDeclaration</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~ImportDefaultSpecifier.html">ImportDefaultSpecifier</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~ImportNamespaceSpecifier.html">ImportNamespaceSpecifier</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~ImportSpecifier.html">ImportSpecifier</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~ImportSpecifierAbstract.html">ImportSpecifierAbstract</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~LabeledStatement.html">LabeledStatement</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~Literal.html">Literal</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~LogicalExpression.html">LogicalExpression</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~MemberExpression.html">MemberExpression</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~MethodDefinition.html">MethodDefinition</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~ModuleSpecifier.html">ModuleSpecifier</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~NewExpression.html">NewExpression</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~Node.html">Node</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~ObjectExpression.html">ObjectExpression</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~ObjectPattern.html">ObjectPattern</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~Pattern.html">Pattern</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~Program.html">Program</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~Property.html">Property</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~RestElement.html">RestElement</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~ReturnStatement.html">ReturnStatement</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~SequenceExpression.html">SequenceExpression</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~SpreadElement.html">SpreadElement</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~Statement.html">Statement</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~SwitchCase.html">SwitchCase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~SwitchStatement.html">SwitchStatement</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~TaggedTemplateExpression.html">TaggedTemplateExpression</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~TemplateElement.html">TemplateElement</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~TemplateLiteral.html">TemplateLiteral</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~ThisExpression.html">ThisExpression</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~ThrowStatement.html">ThrowStatement</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~TryStatement.html">TryStatement</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~UnaryExpression.html">UnaryExpression</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~UpdateExpression.html">UpdateExpression</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~VariableDeclaration.html">VariableDeclaration</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~VariableDeclarator.html">VariableDeclarator</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~WhileStatement.html">WhileStatement</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~YieldExpression.html">YieldExpression</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-singleCharLoc">singleCharLoc</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-fromObject">fromObject</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-mangleIdentifier">mangleIdentifier</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-needsMangle">needsMangle</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-propertyNameOk">propertyNameOk</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-unmangle">unmangle</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-render">render</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-renderWithSourceMap">renderWithSourceMap</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-identifier">identifier</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-loc">loc</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-member">member</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-propertyIdOrLiteral">propertyIdOrLiteral</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-toStatement">toStatement</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-StartColumn">StartColumn</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-StartLine">StartLine</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-StartPos">StartPos</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-AssignmentOperator">AssignmentOperator</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-BinaryOperator">BinaryOperator</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-LogicalOperator">LogicalOperator</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-MethodDefinitionKind">MethodDefinitionKind</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-PropertyKind">PropertyKind</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-UnaryOperator">UnaryOperator</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-UpdateOperator">UpdateOperator</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-VariableDeclarationKind">VariableDeclarationKind</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-forbiddenNames">forbiddenNames</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/ast.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/** Base type of all ASTs. */
export class Node {
	/**
	Convert to JSON.
	@see https://github.com/estree/estree
	*/
	toJSON() {
		const obj = { }
		obj.type = this.type
		// Sort to make JSON rendering deterministic.
		Object.keys(this).sort().forEach(key =&gt; { obj[key] = this[key] })
		return obj
	}

	/**
	For compatibility with other AST representations,
	all Node instances have a &apos;type&apos; property that is the name of that type.
	@see https://github.com/estree/estree
	*/
	get type() {
		return this.constructor.name
	}

	/** @override */
	toString() {
		return JSON.stringify(this)
	}
}

// Abstracts
	/** Line that declares new locals. */
	export class Declaration extends Node { }

	/** Blocks of code have lines that are Statements or Declarations. */
	export class Statement extends Node { }

	/**
	Code that has a value.
	To use one in a statement position, see ExpressionStatement.
	*/
	export class Expression extends Node { }

	/**
	Can go in a parameter list or on the left side of an assignment.
	*/
	export class Pattern extends Node { }

// A complete program source tree.
export class Program extends Node {
	constructor(body) {
		super()
		/** @type {Array&lt;Statement&gt;} */
		this.body = body
	}
}

// Variables
	/**
	A JavaScript identifier.

	It is assumed that you have called `mangleIdentifier` as appropriate.
	See also {@link identifier}.
	*/
	export class Identifier extends Expression {
		constructor(name) {
			super()
			/** @type {String} */
			this.name = name
		}
	}

	/** Single declaration within a {@link VariableDeclaration}. */
	export class VariableDeclarator extends Node {
		constructor(id, init) {
			// TODO:ES6 Optional args
			if (init=== undefined)
				init = null
			super()
			/** @type {Pattern} */
			this.id = id
			/** @type {?Expression} */
			this.init = init
		}
	}

	/** Accepted kinds of {@link VariableDeclaration}. */
	export const VariableDeclarationKind = new Set([&apos;const&apos;, &apos;let&apos;, &apos;var&apos;])
	/**
	Declares and optionally initializes many variables.
	Must be at least one declaration.
	*/
	export class VariableDeclaration extends Declaration {
		constructor(kind, declarations) {
			super()
			/** @type {VariableDeclarationKind} */
			this.kind = kind
			/** @type {Array&lt;VariableDeclarator&gt;} */
			this.declarations = declarations
			if (this.declarations.length === 0)
				throw new Error(&apos;VariableDeclaration must have at least 1 declaration.&apos;)
		}
	}


// Statements
	/**
	An empty statement, i.e., a solitary semicolon.
	Not useful for code generation, but some parsers will return these.
	*/
	export class EmptyStatement extends Statement { }

	/** A block statement, i.e., a sequence of statements surrounded by braces. */
	export class BlockStatement extends Statement {
		constructor(body) {
			super()
			/** @type {Array&lt;Statement&gt;} */
			this.body = body
		}
	}

	/**
	An expression statement, i.e., a statement consisting of a single expression.
	See `esast.util toStatement toStatements`.
	*/
	export class ExpressionStatement extends Statement {
		constructor(expression) {
			super()
			/** @type {Expression} */
			this.expression = expression
		}
	}

	/** An if (or if ... else) statement. */
	export class IfStatement extends Statement {
		constructor(test, consequent, alternate) {
			// TODO:ES6 Optional arguments
			if (alternate === undefined)
				alternate = null
			super()
			/** @type {Expression} */
			this.test = test
			/** @type {Statement} */
			this.consequent = consequent
			/** @type {?Statement} */
			this.alternate = alternate
		}
	}

	/** A statement prefixed by a label. */
	export class LabeledStatement extends Statement {
		constructor(label, body) {
			super()
			/** @type {Identifier} */
			this.label = label
			/** @type {Statement} */
			this.body = body
		}
	}

	export class BreakStatement extends Statement {
		/** The `break` keyword. */
		constructor(label) {
			// TODO:ES6 Optional args
			if (label === undefined)
				label = null
			super()
			/** @type {?Identifier} */
			this.label = label
		}
	}

	/** The `continue` keyword. */
	export class ContinueStatement extends Statement {
		constructor(label) {
			// TODO:ES6 Optional args
			if (label === undefined)
				label = null
			super()
			/** @type {?Identifier} */
			this.label = label
		}
	}

	/**
	`switch (discriminant) { cases }`
	Only the last entry of `cases` is allowed to be `default`.
	*/
	export class SwitchStatement extends Statement {
		constructor(discriminant, cases) {
			super()
			/** @type {Expression} */
			this.discriminant = discriminant
			/** @type {Array&lt;SwitchCase&gt;} */
			this.cases = cases
		}
	}
	/**
	A single `case` within a SwitchStatement.
	If `test` is `null`, this is the `default` case.
	*/
	export class SwitchCase extends Statement {
		constructor(test, consequent) {
			// TODO:ES6 Optional args
			if (test === undefined)
				test = null
			super()
			/** @type {?Expression} */
			this.test = test
			/** @type {Array&lt;Statement&gt; */
			this.consequent = consequent
		}
	}

	/** The `return` keyword, optionally followed by an Expression to return. */
	export class ReturnStatement extends Statement {
		constructor(argument) {
			// TODO:ES6 Optional args
			if (argument === undefined)
				argument = null
			super()
			/** @type {?Expression} */
			this.argument = argument
		}
	}

	/**
	The `throw` keyword, and something to throw.
	See `esast.util throwError`.
	*/
	export class ThrowStatement extends Statement {
		constructor(argument) {
			super()
			/** @type {Expression} */
			this.argument = argument
		}
	}

	/**
	`try { block } catch (handler.param) { handler.body } finally { finalizer }`
	At least one of `handler` or `finalizer` must be non-null.
	*/
	export class TryStatement extends Statement {
		constructor(block, handler, finalizer) {
			// TODO:ES6 Optional args
			if (handler === undefined)
				handler = null
			if (finalizer === undefined)
				finalizer = null
			super()
			/** @type {BlockStatement} */
			this.block = block
			/** @type {?CatchClause} */
			this.handler = handler
			/** @type {?BlockStatement} */
			this.finalizer = finalizer
		}
	}
	/** Must be *part* of a {@link TryStatement} -- does *not* follow it. */
	export class CatchClause extends Node {
		constructor(param, body) {
			super()
			/** @type {Pattern} */
			this.param = param
			/** @type {BlockStatement} */
			this.body = body
		}
	}

	/** `while (test) body` */
	export class WhileStatement extends Statement {
		constructor(test, body) {
			super()
			/** @type {Expression} */
			this.test = test
			/** @type {Statement} */
			this.body = body
		}
	}

	/** `do body while (test)` */
	export class DoWhileStatement extends Statement {
		constructor(body, test) {
			super()
			/** @type {Statement} */
			this.body = body
			/** @type {Expression} */
			this.test = test
		}
	}

	/**
	`for (init; test; update) body`
	Not to be confused with ForInStatement or ForOfStatement.
	*/
	export class ForStatement extends Statement {
		constructor(init, test, update, body) {
			super()
			/** @type {?(VariableDeclaration | Expression)} */
			this.init = init
			/** @type {?Expression} */
			this.test = test
			/** @type {?Expression} */
			this.update = update
			/** @type {Statement} */
			this.body = body
		}
	}

	/** `for (left in right) body` */
	export class ForInStatement extends Statement {
		constructor(left, right, body) {
			super()
			/** @type {VariableDeclaration | Expression} */
			this.left = left
			/** @type {Expression} */
			this.right = right
			/** @type {Statement} */
			this.body = body
		}
	}

	/** `for (left of right) body` */
	export class ForOfStatement extends Statement {
		constructor(left, right, body) {
			super()
			/** @type {VariableDeclaration | Expression} */
			this.left = left
			/** @type {Expression} */
			this.right = right
			/** @type {Statement} */
			this.body = body
		}
	}

	/** The `debugger` keyword. */
	export class DebuggerStatement extends Statement { }

// Declarations
	/** FunctionDeclaration | FunctionExpression | ArrowFunctionExpression */
	export class FunctionAbstract extends Node { }

	class FunctionNonArrow extends FunctionAbstract {
		constructor(id, params, body, generator) {
			// TODO:ES6 Optional args
			if (generator === undefined)
				generator = false
			super()
			/** @type {Identifier} */
			this.id = id
			/** @type {Array&lt;Pattern&gt;} */
			this.params = params
			/** @type {BlockStatement} */
			this.body = body
			/** @type {boolean} */
			this.generator = generator
		}
	}

	// TODO: Declaration too
	/** {@link Function} in declaration position. */
	export class FunctionDeclaration extends FunctionNonArrow { }

// Expressions
	export class Literal extends Expression {
		constructor(value) {
			super()
			/** @type {number|string|boolean|null} */
			this.value = value
		}
	}

	/** The `this` keyword. */
	export class ThisExpression extends Expression { }

	/** `[ elements ]` */
	export class ArrayExpression extends Expression {
		constructor(elements) {
			super()
			/** @type {Array&lt;?Expression&gt;} */
			this.elements = elements
		}
	}

	/** Accepted kinds of {@link Property}. */
	export const PropertyKind = new Set([&apos;init&apos;, &apos;get&apos;, &apos;set&apos;])
	/** Part of an ObjectExpression. */
	export class Property extends Node {
		constructor(kind, key, value=key, computed=!(key instanceof Identifier), method=false) {
			super()
			/** @type {PropertyKind} */
			this.kind = kind
			/** @type {Literal | Identifier} */
			this.key = key
			/** @type {Expression} */
			this.value = value
			/** @type {boolean} */
			this.computed = computed
			/** @type {boolean} */
			this.method = method

			if (this.kind !== &apos;init&apos;) {
				if (!(this.value instanceof FunctionExpression))
					throw new Error(&apos;get/set Property\&apos;s value must be a FunctionExpression.&apos;)
				if (this.value.id !== null)
					throw new Error(
						&apos;get/set Property\&apos;s value must not have id; &apos; +
						&apos;that is stored in the `key` of the Property.&apos;)
				if (this.value.generator)
					throw new Error(&apos;get/set can not be a generator.&apos;)
				if (this.method)
					throw new Error(&apos;get/set can not have method: true.&apos;)
			} else if (this.method) {
				if (!(this.value instanceof FunctionExpression))
					throw new Error(&apos;method Property\&apos;s value must be a FunctionExpression.&apos;)
			}
		}

		get shorthand() {
			return this.value === this.key
		}
	}

	/** An object literal. */
	export class ObjectExpression extends Expression {
		constructor(properties) {
			super()
			/** @type {Array&lt;Property&gt;} */
			this.properties = properties
		}
	}

	// TODO: Expression too
	/** {@link Function} in expression position. */
	export class FunctionExpression extends FunctionNonArrow { }

	/** Like FunctionExpression but uses the `params =&gt; body` form. */
	// TODO: extends FunctionAbstract too
	export class ArrowFunctionExpression extends Expression {
		constructor(params, body) {
			super()
			/** @type {Array&lt;Pattern&gt;} */
			this.params = params
			/** @type {BlockStatement | Expression} */
			this.body = body
		}
	}

	/**
	`expressions[0], expressions[1], ...`
	Expression composed of other expressions, separated by the comma operator.
	*Not* for parameter lists.
	*/
	export class SequenceExpression extends Expression {
		constructor(expressions) {
			super()
			/** @type {Array&lt;Expression&gt;} */
			this.expressions = expressions
		}
	}

	/** Accepted kinds of {@link UnaryExpression}. */
	export const UnaryOperator = new Set([&apos;-&apos;, &apos;+&apos;, &apos;!&apos;, &apos;~&apos;, &apos;typeof&apos;, &apos;void&apos;, &apos;delete&apos;])
	/**
	`operator argument`
	Calls a unary operator.
	*/
	export class UnaryExpression extends Expression {
		constructor(operator, argument) {
			super()
			/** @type {UnaryOperator} */
			this.operator = operator
			/** @type {Expression} */
			this.argument = argument
		}

		/** Always true. Needed for comparibility with estree. */
		get prefix() {
			return true
		}
	}

	/** Accepted kinds of {@link BinaryExpression}. */
	export const BinaryOperator = new Set([
		&apos;==&apos;, &apos;!=&apos;, &apos;===&apos;, &apos;!==&apos;,
		&apos;&lt;&apos;, &apos;&lt;=&apos;, &apos;&gt;&apos;, &apos;&gt;=&apos;,
		&apos;&lt;&lt;&apos;, &apos;&gt;&gt;&apos;, &apos;&gt;&gt;&gt;&apos;,
		&apos;+&apos;, &apos;-&apos;, &apos;*&apos;, &apos;/&apos;, &apos;%&apos;,
		&apos;|&apos;, &apos;^&apos;, &apos;&amp;&apos;, &apos;in&apos;,
		&apos;instanceof&apos;])
	/**
	`left operator right`
	Calls a binary operator.
	*/
	export class BinaryExpression extends Expression {
		constructor(operator, left, right) {
			super()
			/** @type {BinaryOperator} */
			this.operator = operator
			/** @type {Expression} */
			this.left = left
			/** @type {Expression} */
			this.right = right
		}
	}

	/** Accepted kinds of {@link AssignmentExpression}. */
	export const AssignmentOperator = new Set([
		&apos;=&apos;, &apos;+=&apos;, &apos;-=&apos;, &apos;*=&apos;, &apos;/=&apos;, &apos;%=&apos;,
		&apos;&lt;&lt;=&apos;, &apos;&gt;&gt;=&apos;, &apos;&gt;&gt;&gt;=&apos;,
		&apos;|=&apos;, &apos;^=&apos;, &apos;&amp;=&apos;
	])
	/**
	`left operator right`
	Mutates an existing variable.
	Do not confuse with VariableDeclaration.
	*/
	export class AssignmentExpression extends Expression {
		constructor(operator, left, right) {
			super()
			/** @type {AssignmentOperator} */
			this.operator = operator
			/** @type {Pattern} */
			this.left = left
			/** @type {Expression} */
			this.right = right
		}
	}

	/** Accepted kinds of {@link UpdateExpression}. */
	export const UpdateOperator = new Set([&apos;++&apos;, &apos;--&apos;])
	/**
	`++argument` or `argument++`
	Increments or decrements a number.
	*/
	export class UpdateExpression extends Expression {
		constructor(operator, argument, prefix) {
			super()
			/** @type {UpdateOperator} */
			this.operator = operator
			/** @type {Expression} */
			this.argument = argument
			/** @type {boolean} */
			this.prefix = prefix
		}
	}

	/** Accepted kinds of {@link LogicalExpression}. */
	export const LogicalOperator = new Set([&apos;||&apos;, &apos;&amp;&amp;&apos;])
	/**
	`left operator right`
	Calls a lazy logical operator.
	*/
	export class LogicalExpression extends Expression {
		constructor(operator, left, right) {
			super()
			/** @type {LogicalOperator} */
			this.operator = operator
			/** @type {Expression} */
			this.left = left
			/** @type {Expression} */
			this.right = right
		}
	}

	/** `test ? consequent : alternate` */
	export class ConditionalExpression extends Expression {
		constructor(test, consequent, alternate) {
			super()
			/** @type {Expression} */
			this.test = test
			/** @type {Expression} */
			this.consequent = consequent
			/** @type {Expression} */
			this.alternate = alternate
		}
	}

	/**
	`new callee(arguments)`
	Just like {@link CallExpression} but with `new` in front.
	*/
	export class NewExpression extends Expression {
		constructor(callee, _arguments) {
			super()
			/** @type {Expression} */
			this.callee = callee
			/** @type {Array&lt;Expression&gt;} */
			this.arguments = _arguments
		}
	}

	/** `callee(arguments)` */
	export class CallExpression extends Expression {
		constructor(callee, _arguments) {
			super()
			/** @type {Expression} */
			this.callee = callee
			/** @type {Array&lt;Expression&gt;} */
			this.arguments = _arguments
		}
	}
	/** `...args` in a CallExpression. */
	export class SpreadElement extends Node {
		constructor(argument) {
			super()
			/** @type {Expression} */
			this.argument = argument
		}
	}

	/**
	If computed === true, `object[property]`.
	Else, `object.property` -- meaning property should be an Identifier.
	*/
	export class MemberExpression extends Expression {
		constructor(object, property) {
			super()
			/** @type {Expression} */
			this.object = object
			/** @type {Expression} */
			this.property = property
		}

		/** Needed for compatibility with estree. */
		get computed() {
			return !(this.property instanceof Identifier)
		}
	}

	/** `yield argument` or `yield* argument` */
	export class YieldExpression extends Expression {
		constructor(argument, delegate) {
			super()
			/** @type {?Expression} */
			this.argument = argument
			/** @type {boolean} */
			this.delegate = delegate

			if (this.delegate &amp;&amp; this.argument === null)
				throw new Error(&apos;Can not yield* without argument.&apos;)
		}
	}

	// Templates
		/**
		A template with no tag.
		It alternates between quasis and expressions.
		It should begin and end with quasis, using {@link TemplateElement.empty} if necessary.
		This means that `${1}${2}` has 3 empty quasis!
		*/
		export class TemplateLiteral extends Expression {
			constructor(quasis, expressions) {
				super()
				/** @type {Array&lt;TemplateElement&gt;} */
				this.quasis = quasis
				/** @type {Array&lt;Expression&gt;} */
				this.expressions = expressions
				if (this.quasis.length !== this.expressions.length + 1)
					throw new Error(
						&apos;There must be 1 more quasi than expressions.\n&apos; +
						&apos;Maybe you need to add an empty quasi to the front or end.&apos;)
			}
		}

		/** Part of a TemplateLiteral. */
		export class TemplateElement extends Node {
			/**
			TemplateElement whose raw source is `str`.
			@param {string} str
			*/
			static forRawString(str) {
				return new TemplateElement(false, {
					// TODO: A way to calculate this?
					cooked: null,
					raw: str
				})
			}

			/**
			TemplateElement evaluating to `str`.
			Uses escape sequences as necessary.
			@param {string} str
			*/
			static forString(str) {
				return new TemplateElement(false, {
					cooked: str,
					raw: escapeStringForTemplate(str)
				})
			}

			/** TemplateElement with empty value. */
			static get empty() {
				return this.forString(&apos;&apos;)
			}

			constructor(tail, value) {
				super()
				/**
				Use this to mark the last TemplateElement.
				@type {boolean}
				*/
				this.tail = tail
				/** @type {{cooked: string, raw: string}} */
				this.value = value
			}
		}

		const
			escapeStringForTemplate = str =&gt;
				str.replace(/[{\\`\n\t\b\f\v\r\u2028\u2029]/g, ch =&gt; templateEscapes[ch]),
			templateEscapes = {
				// Need to make sure &quot;${&quot; is escaped.
				&apos;{&apos;: &apos;\\{&apos;,
				&apos;`&apos;: &apos;\\`&apos;,
				&apos;\\&apos;: &apos;\\\\&apos;,
				&apos;\n&apos;: &apos;\\n&apos;,
				&apos;\t&apos;: &apos;\\t&apos;,
				&apos;\b&apos;: &apos;\\b&apos;,
				&apos;\f&apos;: &apos;\\f&apos;,
				&apos;\v&apos;: &apos;\\v&apos;,
				&apos;\r&apos;: &apos;\\r&apos;,
				&apos;\u2028&apos;: &apos;\\u2028&apos;,
				&apos;\u2029&apos;: &apos;\\u2029&apos;
			}

		/** TemplateLiteral with a tag in front, like`this`. */
		export class TaggedTemplateExpression extends Expression {
			constructor(tag, quasi) {
				super()
				/** @type {Expression} */
				this.tag = tag
				/** @type {TemplateLiteral} */
				this.quasi = quasi
			}
		}

// Patterns
	/**
	`{ a, b: c } =`
	Object deconstructing pattern.
	*/
	export class ObjectPattern extends Pattern {
		constructor(properties) {
			super()
			/** @type {Array&lt;AssignmentProperty&gt;} */
			this.properties = properties
		}
	}

	/**
	Just like a Property, but kind is always `init`.
	Although technically its own type, `_.type` will be &apos;Property&apos;.
	*/
	export class AssignmentProperty extends Node {
		constructor(key, value) {
			// TODO:ES6 Optional args
			if (value === undefined)
				value = key
			super()
			/** @type {Identifier} */
			this.key = key
			/** @type {Pattern} */
			this.value = value
		}

		get type() { return &apos;Property&apos; }
		get kind() { return &apos;init&apos; }
		get method() { return false }
		get shorthand() {
			return this.value === this.key
		}
		get computed() {
			return !(this.key instanceof Identifier)
		}
	}

	/**
	`[ a, b ] = ...`.
	Array deconstructing pattern.
	*/
	export class ArrayPattern extends Pattern {
		constructor(elements) {
			super()
			/** @type {Array&lt;?Pattern&gt;} */
			this.elements = elements
		}
	}

	/**
	Can be the last argument to a FunctionExpression/FunctionDeclaration
	or  go at the end of an ArrayPattern.
	*/
	export class RestElement extends Pattern {
		constructor(argument) {
			super()
			/** @type {Pattern} */
			this.argument = argument
		}
	}

// Classes
	/** Accepted kinds of {@link MethodDefinition}. */
	export const MethodDefinitionKind = new Set([&apos;constructor&apos;, &apos;method&apos;, &apos;get&apos;, &apos;set&apos;])
	/** Part of a {@link ClassBody}. */
	export class MethodDefinition extends Node {
		/** @param {FunctionExpression} value */
		static constructor(value) {
			return new MethodDefinition(new Identifier(&apos;constructor&apos;), value, &apos;constructor&apos;)
		}

		constructor(key, value, kind, _static, computed) {
			// TODO:ES6 Optional args
			if (_static === undefined)
				_static = false
			if (computed === undefined)
				computed = false
			if (kind === &apos;constructor&apos; &amp;&amp; !(
				key instanceof Identifier  &amp;&amp; key.name === &apos;constructor&apos; &amp;&amp; !_static &amp;&amp; !computed))
				throw new Error(
					&apos;Constructor method should created with `MethodDefinition.constructor`.&apos;)
			super()
			/** @type {Identifier | Literal} */
			this.key = key
			/** @type {FunctionExpression} */
			this.value = value
			/** @type {MethodDefinitionKind} */
			this.kind = kind
			/** @type {boolean} */
			this.static = _static
			/** @type {boolean} */
			this.computed = computed

			if (value.id !== null)
				throw new Error(
					&apos;MethodDefinition value should not have id; that is handled by `key`.&apos;)
		}
	}

	/** Contents of a {@link Class}. */
	export class ClassBody extends Node {
		constructor(body) {
			super()
			/** @type {Array&lt;MethodDefinition&gt;} */
			this.body = body
		}
	}

	/** {@link ClassDeclaration} | {@link ClassExpression} */
	export class Class extends Node { }

	// TODO: extends Declaration too
	/** {@link Class} in declaration position. */
	export class ClassDeclaration extends Class {
		constructor(id, superClass, body) {
			super()
			/** @type {Identifier} */
			this.id = id
			/** @type {?Expression} */
			this.superClass = superClass
			/** @type {ClassBody} */
			this.body = body
		}
	}

	/** {@link Class} in expression position. */
	export class ClassExpression extends Class {
		constructor(id, superClass, body) {
			super()
			/** @type {?Identifier} */
			this.id = id
			/** @type {?Expression} */
			this.superClass = superClass
			/** @type {ClassBody} */
			this.body = body
		}
	}

// Modules
	/** A specifier in an import or export declaration. */
	export class ModuleSpecifier extends Node { }

	/**
	{@link ImportSpecifier} | {@link ImportDefaultSpecifier} | {@link ImportNamespaceSpecifier}
	*/
	export class ImportSpecifierAbstract extends Node { }

	/**
	`import specifiers from source`
	Only one specifier may be a ImportDefaultSpecifier.
	If there is an ImportNamespaceSpecifier, it must be the only specifier.
	*/
	export class ImportDeclaration extends Node {
		constructor(specifiers, source) {
			super()
			/** @type {Array&lt;ImportSpecifierAbstract&gt;} */
			this.specifiers = specifiers
			/** @type {Literal&lt;string&gt;} */
			this.source = source
		}
	}

	/**
	A non-default import. Used in an ImportDeclaration.
	For `import { a } from &quot;source&quot;`, just pass one argument and local will = imported.
	For `import { a as b } from &quot;source&quot;`, make imported `a` and local `b`.
	*/
	export class ImportSpecifier extends ModuleSpecifier {
		constructor(imported, local) {
			// TODO:ES6 Optional args
			if (local === undefined)
				local = imported
			super()
			/** @type {Identifier} */
			this.imported = imported
			/** @type {Identifier} */
			this.local = local
		}
	}

	/** The default export, as in `import a from &quot;source&quot;`. */
	export class ImportDefaultSpecifier extends ImportSpecifierAbstract {
		constructor(local) {
			super()
			/** @type {Identifier} */
			this.local = local
		}
	}

	/** Object of every export, as in `import * as a from &quot;source&quot;`. */
	export class ImportNamespaceSpecifier extends ImportSpecifierAbstract {
		constructor(local) {
			super()
			/** @type {Identifier} */
			this.local = local
		}
	}

	/**
	A non-default export. Used in an ExportNamedDeclaration.
	For `export { a } from &quot;source&quot;`, just pass one argument local will = exported.
	For `export { a as b }`, make exported `b` and local `a`.
	*/
	export class ExportSpecifier extends ModuleSpecifier {
		constructor(exported, local) {
			// TODO:ES6 Optional args
			if (local === undefined)
				local = exported
			super()
			/** @type {Identifier} */
			this.exported = exported
			/** @type {Identifier} */
			this.local = local
		}
	}

	/**
	Exports multiple values as in `export { a, b as c }`.
	If source !== null,
	re-exports from that module as in `export { ... } from &quot;source&quot;`.
	*/
	export class ExportNamedDeclaration extends Node {
		constructor(declaration, specifiers, source) {
			// TODO:ES6 Optional arguments
			if (specifiers === undefined)
				specifiers = []
			if (source === undefined)
				source = null

			super()
			/** @type {?Declaration} */
			this.declaration = declaration
			/** @type {Array&lt;ExportSpecifier&gt;} */
			this.specifiers = specifiers
			/** @type {?Literal&lt;string&gt;} */
			this.source = source

			if (declaration !== null &amp;&amp; !(specifiers.length === 0 &amp;&amp; source === null))
				throw new Error(&apos;Declaration can not be combined with specifiers/source.&apos;)
		}
	}

	/** `export default declaration` */
	export class ExportDefaultDeclaration extends Node {
		constructor(declaration) {
			super()
			/** @type {Declaration | Expression} */
			this.declaration = declaration
		}
	}

	/** `export * from source` */
	export class ExportAllDeclaration extends Node {
		constructor(source) {
			super()
			/** @type {Literal&lt;string&gt;} */
			this.source = source
		}
	}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.3)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
