if (typeof define !== 'function') var define = require('amdefine')(module);define(['exports', 'tupl/dist/tupl', 'tupl/dist/type', './private/util'], function (exports, _tuplDistTupl, _tuplDistType, _privateUtil) {
	'use strict';

	Object.defineProperty(exports, '__esModule', {
		value: true
	});

	function _interopRequire(obj) { return obj && obj.__esModule ? obj['default'] : obj; }

	var _tupl = _interopRequire(_tuplDistTupl);

	var Node = (0, _tuplDistTupl.abstract)('Node', Object, 'Base type of all Asts.'),
	    Declaration = (0, _tuplDistTupl.abstract)('Declaration', Node, 'Identifier declaration.'),
	    Statement = (0, _tuplDistTupl.abstract)('Statement', Node, 'Blocks of code have lines that are Statements or Declarations.'),
	    Expression = (0, _tuplDistTupl.abstract)('Expression', Node, 'Code that has a value. To use one in a statement position, see ExpressionStatement.'),
	    Pattern = (0, _tuplDistTupl.abstract)('Pattern', Node, 'Can go in a parameter list or on the left side of an assignment.');

	exports.Node = Node;
	exports.Declaration = Declaration;
	exports.Statement = Statement;
	exports.Expression = Expression;
	exports.Pattern = Pattern;
	var makeType = function makeType(superType) {
		return function (name, doc, namesTypes) {
			var proto = arguments[3] === undefined ? {} : arguments[3];

			doc = (0, _privateUtil.dedent)(doc);
			proto.type = name;
			var t = (0, _tupl)(name, superType, doc, namesTypes, proto);
			var oldToString = t.prototype.toString;
			t.prototype.toString = function () {
				var old = oldToString.call(this);
				return this.loc ? '' + this.loc.toString() + '@' + old : old;
			};
			return t;
		};
	};
	var n = makeType(Node),
	    s = makeType(Statement),
	    e = makeType(Expression),
	    d = makeType(Declaration),
	    p = makeType(Pattern);

	var Program = n('Program', 'A complete program source tree.', ['body', [Statement]]),
	    Identifier = n('Identifier', '\n\t\t\tA JavaScript identifier.\n\t\t\tIt is assumed that you have called `mangleIdentifier` as appropriate.\n\t\t\tAlso look at `esast.util idCached`,\n\t\t\twhich mangles and avoids constructing the same identifier twice.', ['name', String]),
	   

	// Statements
	EmptyStatement = s('EmptyStatement', '\n\t\t\tAn empty statement, i.e., a solitary semicolon.\n\t\t\tNot useful for code generation, but some parsers will return these.', []),
	    BlockStatement = s('BlockStatement', 'A block statement, i.e., a sequence of statements surrounded by braces.', ['body', [Statement]]),
	    ExpressionStatement = s('ExpressionStatement', '\n\t\t\tAn expression statement, i.e., a statement consisting of a single expression.\n\t\t\tSee `esast.util toStatement toStatements`.', ['expression', Expression]),
	    IfStatement = s('IfStatement', 'An if (or if ... else) statement.', ['test', Expression, 'consequent', Statement, 'alternate', (0, _tuplDistType.Nullable)(Statement)]),
	    LabeledStatement = s('LabeledStatement', 'A statement prefixed by a label.', ['label', Identifier, 'body', Statement]),
	    BreakStatement = s('BreakStatement', 'The `break` keyword.', ['label', (0, _tuplDistType.Nullable)(Identifier)]),
	    ContinueStatement = s('ContinueStatement', 'The `continue` keyword.', ['label', (0, _tuplDistType.Nullable)(Identifier)]),
	    SwitchCase = n('SwitchCase', '\n\t\t\tA single `case` within a SwitchStatement.\n\t\t\tIf `test` is `null`, this is the `default` case.', ['test', (0, _tuplDistType.Nullable)(Expression), 'consequent', [Statement]]),
	    SwitchStatement = s('SwitchStatement', 'Only the last entry of `cases` is allowed to be `default`.', ['discriminant', Expression, 'cases', [SwitchCase]]),
	    ReturnStatement = s('ReturnStatement', 'The `return` keyword, optionally followed by an Expression to return.', ['argument', (0, _tuplDistType.Nullable)(Expression)]),
	    ThrowStatement = s('ThrowStatement', '\n\t\t\tThe `throw` keyword, and something to throw.\n\t\t\tSee `esast.util throwError`.', ['argument', Expression]),
	    CatchClause = n('CatchClause', 'Must be *part* of a TryStatement -- does *not* follow it.', ['param', Pattern, 'body', BlockStatement]),
	    TryStatement = s('TryStatement',
	// TODO: Assert in postConstruct
	'At least one of `handler` or `finalizer` must be non-null.', ['block', BlockStatement, 'handler', (0, _tuplDistType.Nullable)(CatchClause), 'finalizer', (0, _tuplDistType.Nullable)(BlockStatement)]),
	    WhileStatement = s('WhileStatement', '`while (test) body`.', ['test', Expression, 'body', Statement]),
	    DoWhileStatement = s('DoWhileStatement',
	// TODO: Note that body needs braces!
	'`do { body } while (test)`.', ['body', Statement, 'test', Expression]),
	    ForStatement = s('ForStatement', '\n\t\t\t`for (init; test; update) body`.\n\t\t\tNot to be confused with ForInStatement or ForOfStatement.', ['init', (0, _tuplDistType.Nullable)((0, _tuplDistType.Union)(VariableDeclaration, Expression)), 'test', (0, _tuplDistType.Nullable)(Expression), 'update', (0, _tuplDistType.Nullable)(Expression), 'body', Statement]),
	    ForInStatement = s('ForInStatement', '`for (left in right) body`.', ['left', (0, _tuplDistType.Union)(VariableDeclaration, Expression), 'right', Expression, 'body', Statement]),
	    ForOfStatement = s('ForOfStatement', '`for (left of right) body`.', ['left', (0, _tuplDistType.Union)(VariableDeclaration, Expression), 'right', Expression, 'body', Statement]),
	    DebuggerStatement = s('DebuggerStatement', 'The `debugger` keyword.', []),
	   

	// Declarations
	Function = (0, _tuplDistTupl.abstract)('Function', Node, 'FunctionDeclaration or FunctionExpression.'),
	   
	// TODO: Function too
	FunctionDeclaration = d('FunctionDeclaration', 'Unlike for FunctionExpression, id must not be null.', ['id', Identifier, 'params', [Identifier], 'body', BlockStatement, 'generator', Boolean]),
	    VariableDeclarator = n('VariableDeclarator', 'A single variable within a VariableDeclaration.', ['id', Pattern, 'init', (0, _tuplDistType.Nullable)(Expression)]),
	    VariableDeclarationKind = (0, _privateUtil.newSet)(['const', 'let', 'var']),
	    VariableDeclaration = d('VariableDeclaration',
	// TODO: Assert
	'\n\t\t\tDeclares and optionally initializes many variables.\n\t\t\tMust be at least one declaration.', ['kind', VariableDeclarationKind, 'declarations', [VariableDeclarator]]),
	   

	// Expressions
	ThisExpression = e('ThisExpression', 'The `this` keyword.', []),
	    ArrayExpression = e('ArrayExpression', 'An array literal.', ['elements', [(0, _tuplDistType.Nullable)(Expression)]]),
	    PropertyKind = (0, _privateUtil.newSet)(['init', 'get', 'set']),
	    Property = n('Property',
	// TODO:ASSERT
	'\n\t\t\tPart of an ObjectExpression.\n\t\t\tIf kind is \'get\' or \'set\', then value should be a FunctionExpression.', ['kind', PropertyKind,
	// TODO: LiteralString | LiteralNumber
	'key', (0, _tuplDistType.Union)(Literal, Identifier), 'value', Expression]),
	    ObjectExpression = e('ObjectExpression', 'An object literal.', ['properties', [Property]]),
	   
	// TODO: Inherits from Function
	FunctionExpression = e('FunctionExpression', '\n\t\t\t`function id(params) body` or `function* id(params) body`.\n\t\t\tFunction in an expression position.\n\t\t\tTo declare a function, use FunctionDeclaration, not ExpressionStatement.\n\t\t\tSee also `esast.util thunk` and ArrowFunctionExpression.', ['id', (0, _tuplDistType.Nullable)(Identifier), 'params', [Pattern], 'body', BlockStatement, 'generator', Boolean], {
		postConstruct: function postConstruct() {
			this.generator = Boolean(this.generator);
		}
	}),
	   
	// TODO: Inherits from Function
	ArrowFunctionExpression = e('ArrowFunctionExpression', 'Like FunctionExpression but uses the `params => body` form.', ['params', [Pattern], 'body', (0, _tuplDistType.Union)(BlockStatement, Expression)]),
	    SequenceExpression = e('SequenceExpression', '\n\t\t\t`expressions[0], expressions[1], ...`.\n\t\t\tExpression composed of other expressions, separated by the comma operator.\n\t\t\t*Not* for parameter lists.', ['expressions', [Expression]]),
	   
	// TODO: test `- new X`. Probably need parens around argument.
	UnaryOperator = (0, _privateUtil.newSet)(['-', '+', '!', '~', 'typeof', 'void', 'delete']),
	    UnaryExpression = e('UnaryExpression', '`operator argument`. Calls a unary operator.', ['operator', UnaryOperator, 'argument', Expression]),
	    BinaryOperator = (0, _privateUtil.newSet)(['==', '!=', '===', '!==', '<', '<=', '>', '>=', '<<', '>>', '>>>', '+', '-', '*', '/', '%', '|', '^', '&', 'in', 'instanceof']),
	   
	// TODO: Render with parens
	BinaryExpression = e('BinaryExpression', '`left operator right`. Calls a binary operator.', ['operator', BinaryOperator, 'left', Expression, 'right', Expression]),
	    AssignmentOperator = (0, _privateUtil.newSet)(['=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=', '|=', '^=', '&=']),
	    AssignmentExpression = e('AssignmentExpression', '\n\t\t\t`left operator right`.\n\t\t\tMutates an existing variable.\n\t\t\tDo not confuse with VariableDeclaration.', ['operator', AssignmentOperator, 'left', Pattern, 'right', Expression]),
	    UpdateOperator = (0, _privateUtil.newSet)(['++', '--']),
	    UpdateExpression = e('UpdateExpression', '`++argument` or `argument++`. Increments or decrements a number.', ['operator', UpdateOperator, 'argument', Expression, 'prefix', Boolean]),
	    LogicalOperator = (0, _privateUtil.newSet)(['||', '&&']),
	    LogicalExpression = e('LogicalExpression', '`left operator right`. Calls a lazy logical operator.', ['operator', LogicalOperator, 'left', Expression, 'right', Expression]),
	    ConditionalExpression = e('ConditionalExpression', '`test ? consequent : alternate`.', ['test', Expression, 'consequent', Expression, 'alternate', Expression]),
	    NewExpression = e('NewExpression', 'Just like CallExpression but with `new` in front.', ['callee', Expression, 'arguments', [Expression]]),
	    CallExpression = e('CallExpression', '`callee(arguments)`.', ['callee', Expression, 'arguments', [Expression]]),
	    MemberExpression = e('MemberExpression',
	// TODO:ASSERT
	'\n\t\t\tIf computed === true, `object[property]`.\n\t\t\tElse, `object.property` -- meaning property should be an Identifier.', ['object', Expression, 'property', Expression, 'computed', Boolean]),
	    YieldExpression = e('YieldExpression', '`yield argument` or `yield* argument`.', ['argument', Expression, 'delegate', Boolean]),
	   
	// TODO: Literal as abstract type
	// Value: Number | String | null | Boolean
	Literal = e('Literal', 'A literal token.', ['value', Object]),
	   

	// Templates
	// TODO: test, document
	TemplateElement = n('TemplateElement', 'doc', ['tail', Boolean,
	// TODO:estree spec says { cooked, value }, but acorn uses { cooked, raw }
	// TODO: { cooked:String, raw:String } data structure
	'value', Object]),
	    TemplateLiteral = e('TemplateLiteral', 'doc', ['quasis', [TemplateElement], 'expressions', [Expression]]),
	    TaggedTemplateExpression = e('TaggedTemplateExpression', 'doc', ['tag', Expression, 'quasi', TemplateLiteral]),
	   

	// Patterns
	AssignmentProperty = makeType(Property)('AssignmentProperty', '\n\t\t\tJust like a Property, but kind is always `init`.\n\t\t\tAlthough technically its own type, `_.type` will be \'Property\'.', ['key', Identifier, 'value', Pattern], {
		type: 'Property',
		method: false,
		postConstruct: function postConstruct() {
			if (this.value === null) this.value = this.key;
			this.kind = 'init';
		}
	}),
	    ObjectPattern = p('ObjectPattern', '`{ a, b: c } = ...`. Object deconstructing pattern.', ['properties', [AssignmentProperty]]),
	    ArrayPattern = p('ArrayPattern', '`[ a, b ] = ...`. Array deconstructing pattern.', ['elements', [(0, _tuplDistType.Nullable)(Pattern)]]),
	    RestElement = p('RestElement',
	// TODO:TEST
	'\n\t\t\tCan be the last argument to a FunctionExpression/FunctionDeclaration\n\t\t\tor  go at the end of an ArrayPattern.', ['argument', Pattern]),
	   
	// TODO: What is this?
	// AssignmentPattern = p('AssignmentPattern',
	//	'left', Pattern,
	//	'right', Pattern),

	MethodDefinitionKind = (0, _privateUtil.newSet)(['constructor', 'method', 'get', 'set']),
	    MethodDefinition = n('MethodDefinition',
	// TODO:Assert
	// TODO: util method for constructor.
	'\n\t\t\tPart of a ClassBody.\n\t\t\tIf kind is \'constructor\', key must be Identifier(\'constructor\').', ['key', (0, _tuplDistType.Union)(Identifier, Literal), 'value', FunctionExpression, 'kind', MethodDefinitionKind, 'static', Boolean, 'computed', Boolean]),
	    ClassBody = n('ClassBody', 'Contents of a Class.', ['body', [MethodDefinition]]),
	    Class = (0, _tuplDistTupl.abstract)('Class', Node, 'ClassDeclaration or ClassExpression.'),
	   
	// TODO: extends Declaration too
	ClassDeclaration = makeType(Class)('ClassDeclaration', 'Class in declaration position.', ['id', Identifier, 'superClass', (0, _tuplDistType.Nullable)(Expression), 'body', ClassBody]),
	    ClassExpression = makeType(Class)('ClassExpression',
	// TODO: Test class with no superClass
	'Class in expression position.', ['id', (0, _tuplDistType.Nullable)(Identifier), 'superClass', (0, _tuplDistType.Nullable)(Expression), 'body', ClassBody]),
	    ModuleSpecifier = (0, _tuplDistTupl.abstract)('ModuleSpecifier', Node, 'A specifier in an import or export declaration.'),
	    ImportSpecifierAbstract = (0, _tuplDistTupl.abstract)('ImportSpecifierAbstract', Node, 'ImportSpecifier, ImportDefaultSpecifier, or ImportNamespaceSpecifier.'),
	    ImportDeclaration = n('ImportDeclaration',
	// TODO:ASSERT
	'\n\t\t\t`import specifiers from source`.\n\t\t\tOnly one specifier may be a ImportDefaultSpecifier.\n\t\t\tIf there is an ImportNamespaceSpecifier, it must be the only specifier.', ['specifiers', [ImportSpecifierAbstract],
	// TODO: LiteralString
	'source', Literal]),
	    ImportSpecifier = makeType(ModuleSpecifier)('ImportSpecifier', '\n\t\t\tA non-default import. Used in an ImportDeclaration.\n\t\t\tFor `import { a } from "source"`, just pass one argument and local will = imported.\n\t\t\tFor `import { a as b } from "source"`, make imported `a` and local `b`.', ['imported', Identifier, 'local', Identifier], {
		postConstruct: function postConstruct() {
			if (this.local === null) this.local = this.imported;
		}
	}),
	    ImportDefaultSpecifier = makeType(ImportSpecifierAbstract)('ImportDefaultSpecifier', 'The default export, as in `import a from "source"`.', ['local', Identifier]),
	    ImportNamespaceSpecifier = makeType(ImportSpecifierAbstract)('ImportNamespaceSpecifier', 'Object of every export, as in `import * as a from "source"`.', ['local', Identifier]),
	    ExportSpecifier = makeType(ModuleSpecifier)('ExportSpecifier', '\n\t\t\tA non-default export. Used in an ExportNamedDeclaration.\n\t\t\tFor `export { a } from "source"`, just pass one argument local will = exported.\n\t\t\tFor `export { a as b }`, make exported `b` and local `a`.', ['exported', Identifier, 'local', Identifier], {
		postConstruct: function postConstruct() {
			if (this.local === null) this.local = this.exported;
		}
	}),
	    ExportNamedDeclaration = n('ExportNamedDeclaration', '\n\t\t\tExports multiple values as in `export { a, b as c }`.\n\t\t\tIf source !== null,\n\t\t\tre-exports from that module as in `export { ... } from "source"`.', ['declaration', (0, _tuplDistType.Nullable)(Declaration), 'specifiers', [ExportSpecifier],
	// TODO: LiteralString
	'source', (0, _tuplDistType.Nullable)(Literal)]),
	    ExportDefaultDeclaration = n('ExportDefaultDeclaration', '`export default declaration`.', ['declaration', (0, _tuplDistType.Union)(Declaration, Expression)]),
	    ExportAllDeclaration = n('ExportAllDeclaration', '`export * from source`.',
	// TODO:LiteralString
	['source', Literal]);
	exports.Program = Program;
	exports.Identifier = Identifier;
	exports.EmptyStatement = EmptyStatement;
	exports.BlockStatement = BlockStatement;
	exports.ExpressionStatement = ExpressionStatement;
	exports.IfStatement = IfStatement;
	exports.LabeledStatement = LabeledStatement;
	exports.BreakStatement = BreakStatement;
	exports.ContinueStatement = ContinueStatement;
	exports.SwitchCase = SwitchCase;
	exports.SwitchStatement = SwitchStatement;
	exports.ReturnStatement = ReturnStatement;
	exports.ThrowStatement = ThrowStatement;
	exports.CatchClause = CatchClause;
	exports.TryStatement = TryStatement;
	exports.WhileStatement = WhileStatement;
	exports.DoWhileStatement = DoWhileStatement;
	exports.ForStatement = ForStatement;
	exports.ForInStatement = ForInStatement;
	exports.ForOfStatement = ForOfStatement;
	exports.DebuggerStatement = DebuggerStatement;
	exports.Function = Function;
	exports.FunctionDeclaration = FunctionDeclaration;
	exports.VariableDeclarator = VariableDeclarator;
	exports.VariableDeclarationKind = VariableDeclarationKind;
	exports.VariableDeclaration = VariableDeclaration;
	exports.ThisExpression = ThisExpression;
	exports.ArrayExpression = ArrayExpression;
	exports.PropertyKind = PropertyKind;
	exports.Property = Property;
	exports.ObjectExpression = ObjectExpression;
	exports.FunctionExpression = FunctionExpression;
	exports.ArrowFunctionExpression = ArrowFunctionExpression;
	exports.SequenceExpression = SequenceExpression;
	exports.UnaryOperator = UnaryOperator;
	exports.UnaryExpression = UnaryExpression;
	exports.BinaryOperator = BinaryOperator;
	exports.BinaryExpression = BinaryExpression;
	exports.AssignmentOperator = AssignmentOperator;
	exports.AssignmentExpression = AssignmentExpression;
	exports.UpdateOperator = UpdateOperator;
	exports.UpdateExpression = UpdateExpression;
	exports.LogicalOperator = LogicalOperator;
	exports.LogicalExpression = LogicalExpression;
	exports.ConditionalExpression = ConditionalExpression;
	exports.NewExpression = NewExpression;
	exports.CallExpression = CallExpression;
	exports.MemberExpression = MemberExpression;
	exports.YieldExpression = YieldExpression;
	exports.Literal = Literal;
	exports.TemplateElement = TemplateElement;
	exports.TemplateLiteral = TemplateLiteral;
	exports.TaggedTemplateExpression = TaggedTemplateExpression;
	exports.AssignmentProperty = AssignmentProperty;
	exports.ObjectPattern = ObjectPattern;
	exports.ArrayPattern = ArrayPattern;
	exports.RestElement = RestElement;
	exports.MethodDefinitionKind = MethodDefinitionKind;
	exports.MethodDefinition = MethodDefinition;
	exports.ClassBody = ClassBody;
	exports.Class = Class;
	exports.ClassDeclaration = ClassDeclaration;
	exports.ClassExpression = ClassExpression;
	exports.ModuleSpecifier = ModuleSpecifier;
	exports.ImportSpecifierAbstract = ImportSpecifierAbstract;
	exports.ImportDeclaration = ImportDeclaration;
	exports.ImportSpecifier = ImportSpecifier;
	exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
	exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
	exports.ExportSpecifier = ExportSpecifier;
	exports.ExportNamedDeclaration = ExportNamedDeclaration;
	exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
	exports.ExportAllDeclaration = ExportAllDeclaration;
});
//# sourceMappingURL=data:application/json;base64,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ZW50IjpbImltcG9ydCB0dXBsLCB7IGFic3RyYWN0IH0gZnJvbSAndHVwbC9kaXN0L3R1cGwnXG5pbXBvcnQgeyBOdWxsYWJsZSwgVW5pb24gfSBmcm9tICd0dXBsL2Rpc3QvdHlwZSdcbmltcG9ydCB7IGRlZGVudCwgbmV3U2V0IH0gZnJvbSAnLi9wcml2YXRlL3V0aWwnXG5cbmV4cG9ydCBjb25zdFxuXHROb2RlID0gYWJzdHJhY3QoJ05vZGUnLCBPYmplY3QsXG5cdFx0J0Jhc2UgdHlwZSBvZiBhbGwgQXN0cy4nKSxcblx0RGVjbGFyYXRpb24gPSBhYnN0cmFjdCgnRGVjbGFyYXRpb24nLCBOb2RlLFxuXHRcdCdJZGVudGlmaWVyIGRlY2xhcmF0aW9uLicpLFxuXHRTdGF0ZW1lbnQgPSBhYnN0cmFjdCgnU3RhdGVtZW50JywgTm9kZSxcblx0XHQnQmxvY2tzIG9mIGNvZGUgaGF2ZSBsaW5lcyB0aGF0IGFyZSBTdGF0ZW1lbnRzIG9yIERlY2xhcmF0aW9ucy4nKSxcblx0RXhwcmVzc2lvbiA9IGFic3RyYWN0KCdFeHByZXNzaW9uJywgTm9kZSxcblx0XHQnQ29kZSB0aGF0IGhhcyBhIHZhbHVlLiBUbyB1c2Ugb25lIGluIGEgc3RhdGVtZW50IHBvc2l0aW9uLCBzZWUgRXhwcmVzc2lvblN0YXRlbWVudC4nKSxcblx0UGF0dGVybiA9IGFic3RyYWN0KCdQYXR0ZXJuJywgTm9kZSxcblx0XHQnQ2FuIGdvIGluIGEgcGFyYW1ldGVyIGxpc3Qgb3Igb24gdGhlIGxlZnQgc2lkZSBvZiBhbiBhc3NpZ25tZW50LicpXG5cbmNvbnN0IG1ha2VUeXBlID0gc3VwZXJUeXBlID0+IChuYW1lLCBkb2MsIG5hbWVzVHlwZXMsIHByb3RvID0geyB9KSA9PiB7XG5cdGRvYyA9IGRlZGVudChkb2MpXG5cdHByb3RvLnR5cGUgPSBuYW1lXG5cdGNvbnN0IHQgPSB0dXBsKG5hbWUsIHN1cGVyVHlwZSwgZG9jLCBuYW1lc1R5cGVzLCBwcm90bylcblx0Y29uc3Qgb2xkVG9TdHJpbmcgPSB0LnByb3RvdHlwZS50b1N0cmluZ1xuXHR0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdGNvbnN0IG9sZCA9IG9sZFRvU3RyaW5nLmNhbGwodGhpcylcblx0XHRyZXR1cm4gdGhpcy5sb2MgPyBgJHt0aGlzLmxvYy50b1N0cmluZygpfUAke29sZH1gIDogb2xkXG5cdH1cblx0cmV0dXJuIHRcbn1cbmNvbnN0XG5cdG4gPSBtYWtlVHlwZShOb2RlKSxcblx0cyA9IG1ha2VUeXBlKFN0YXRlbWVudCksXG5cdGUgPSBtYWtlVHlwZShFeHByZXNzaW9uKSxcblx0ZCA9IG1ha2VUeXBlKERlY2xhcmF0aW9uKSxcblx0cCA9IG1ha2VUeXBlKFBhdHRlcm4pXG5cbmV4cG9ydCBjb25zdFxuXHRQcm9ncmFtID0gbignUHJvZ3JhbScsXG5cdFx0J0EgY29tcGxldGUgcHJvZ3JhbSBzb3VyY2UgdHJlZS4nLFxuXHRcdFsgJ2JvZHknLCBbU3RhdGVtZW50XSBdKSxcblx0SWRlbnRpZmllciA9IG4oJ0lkZW50aWZpZXInLFxuXHRcdGBcblx0XHRcdEEgSmF2YVNjcmlwdCBpZGVudGlmaWVyLlxuXHRcdFx0SXQgaXMgYXNzdW1lZCB0aGF0IHlvdSBoYXZlIGNhbGxlZCBcXGBtYW5nbGVJZGVudGlmaWVyXFxgIGFzIGFwcHJvcHJpYXRlLlxuXHRcdFx0QWxzbyBsb29rIGF0IFxcYGVzYXN0LnV0aWwgaWRDYWNoZWRcXGAsXG5cdFx0XHR3aGljaCBtYW5nbGVzIGFuZCBhdm9pZHMgY29uc3RydWN0aW5nIHRoZSBzYW1lIGlkZW50aWZpZXIgdHdpY2UuYCxcblx0XHRbICduYW1lJywgU3RyaW5nIF0pLFxuXG5cdC8vIFN0YXRlbWVudHNcblx0RW1wdHlTdGF0ZW1lbnQgPSBzKCdFbXB0eVN0YXRlbWVudCcsXG5cdFx0YFxuXHRcdFx0QW4gZW1wdHkgc3RhdGVtZW50LCBpLmUuLCBhIHNvbGl0YXJ5IHNlbWljb2xvbi5cblx0XHRcdE5vdCB1c2VmdWwgZm9yIGNvZGUgZ2VuZXJhdGlvbiwgYnV0IHNvbWUgcGFyc2VycyB3aWxsIHJldHVybiB0aGVzZS5gLFxuXHRcdFsgXSksXG5cdEJsb2NrU3RhdGVtZW50ID0gcygnQmxvY2tTdGF0ZW1lbnQnLFxuXHRcdCdBIGJsb2NrIHN0YXRlbWVudCwgaS5lLiwgYSBzZXF1ZW5jZSBvZiBzdGF0ZW1lbnRzIHN1cnJvdW5kZWQgYnkgYnJhY2VzLicsXG5cdFx0WyAnYm9keScsIFtTdGF0ZW1lbnRdIF0pLFxuXHRFeHByZXNzaW9uU3RhdGVtZW50ID0gcygnRXhwcmVzc2lvblN0YXRlbWVudCcsXG5cdFx0YFxuXHRcdFx0QW4gZXhwcmVzc2lvbiBzdGF0ZW1lbnQsIGkuZS4sIGEgc3RhdGVtZW50IGNvbnNpc3Rpbmcgb2YgYSBzaW5nbGUgZXhwcmVzc2lvbi5cblx0XHRcdFNlZSBcXGBlc2FzdC51dGlsIHRvU3RhdGVtZW50IHRvU3RhdGVtZW50c1xcYC5gLFxuXHRcdFsgJ2V4cHJlc3Npb24nLCBFeHByZXNzaW9uIF0pLFxuXHRJZlN0YXRlbWVudCA9IHMoJ0lmU3RhdGVtZW50Jyxcblx0XHQnQW4gaWYgKG9yIGlmIC4uLiBlbHNlKSBzdGF0ZW1lbnQuJyxcblx0XHRbXG5cdFx0XHQndGVzdCcsIEV4cHJlc3Npb24sXG5cdFx0XHQnY29uc2VxdWVudCcsIFN0YXRlbWVudCxcblx0XHRcdCdhbHRlcm5hdGUnLCBOdWxsYWJsZShTdGF0ZW1lbnQpXG5cdFx0XSksXG5cdExhYmVsZWRTdGF0ZW1lbnQgPSBzKCdMYWJlbGVkU3RhdGVtZW50Jyxcblx0XHQnQSBzdGF0ZW1lbnQgcHJlZml4ZWQgYnkgYSBsYWJlbC4nLFxuXHRcdFtcblx0XHRcdCdsYWJlbCcsIElkZW50aWZpZXIsXG5cdFx0XHQnYm9keScsIFN0YXRlbWVudFxuXHRcdF0pLFxuXHRCcmVha1N0YXRlbWVudCA9IHMoJ0JyZWFrU3RhdGVtZW50Jyxcblx0XHQnVGhlIGBicmVha2Aga2V5d29yZC4nLFxuXHRcdFsgJ2xhYmVsJywgTnVsbGFibGUoSWRlbnRpZmllcikgXSksXG5cdENvbnRpbnVlU3RhdGVtZW50ID0gcygnQ29udGludWVTdGF0ZW1lbnQnLFxuXHRcdCdUaGUgYGNvbnRpbnVlYCBrZXl3b3JkLicsXG5cdFx0WyAnbGFiZWwnLCBOdWxsYWJsZShJZGVudGlmaWVyKSBdKSxcblx0U3dpdGNoQ2FzZSA9IG4oJ1N3aXRjaENhc2UnLFxuXHRcdGBcblx0XHRcdEEgc2luZ2xlIFxcYGNhc2VcXGAgd2l0aGluIGEgU3dpdGNoU3RhdGVtZW50LlxuXHRcdFx0SWYgXFxgdGVzdFxcYCBpcyBcXGBudWxsXFxgLCB0aGlzIGlzIHRoZSBcXGBkZWZhdWx0XFxgIGNhc2UuYCxcblx0XHRbXG5cdFx0XHQndGVzdCcsIE51bGxhYmxlKEV4cHJlc3Npb24pLFxuXHRcdFx0J2NvbnNlcXVlbnQnLCBbU3RhdGVtZW50XVxuXHRcdF0pLFxuXHRTd2l0Y2hTdGF0ZW1lbnQgPSBzKCdTd2l0Y2hTdGF0ZW1lbnQnLFxuXHRcdCdPbmx5IHRoZSBsYXN0IGVudHJ5IG9mIGBjYXNlc2AgaXMgYWxsb3dlZCB0byBiZSBgZGVmYXVsdGAuJyxcblx0XHRbXG5cdFx0XHQnZGlzY3JpbWluYW50JywgRXhwcmVzc2lvbixcblx0XHRcdCdjYXNlcycsIFtTd2l0Y2hDYXNlXVxuXHRcdF0pLFxuXHRSZXR1cm5TdGF0ZW1lbnQgPSBzKCdSZXR1cm5TdGF0ZW1lbnQnLFxuXHRcdCdUaGUgYHJldHVybmAga2V5d29yZCwgb3B0aW9uYWxseSBmb2xsb3dlZCBieSBhbiBFeHByZXNzaW9uIHRvIHJldHVybi4nLFxuXHRcdFsgJ2FyZ3VtZW50JywgTnVsbGFibGUoRXhwcmVzc2lvbikgXSksXG5cdFRocm93U3RhdGVtZW50ID0gcygnVGhyb3dTdGF0ZW1lbnQnLFxuXHRcdGBcblx0XHRcdFRoZSBcXGB0aHJvd1xcYCBrZXl3b3JkLCBhbmQgc29tZXRoaW5nIHRvIHRocm93LlxuXHRcdFx0U2VlIFxcYGVzYXN0LnV0aWwgdGhyb3dFcnJvclxcYC5gLFxuXHRcdFsgJ2FyZ3VtZW50JywgRXhwcmVzc2lvbiBdKSxcblxuXHRDYXRjaENsYXVzZSA9IG4oJ0NhdGNoQ2xhdXNlJyxcblx0XHQnTXVzdCBiZSAqcGFydCogb2YgYSBUcnlTdGF0ZW1lbnQgLS0gZG9lcyAqbm90KiBmb2xsb3cgaXQuJyxcblx0XHRbXG5cdFx0XHQncGFyYW0nLCBQYXR0ZXJuLFxuXHRcdFx0J2JvZHknLCBCbG9ja1N0YXRlbWVudFxuXHRcdF0pLFxuXHRUcnlTdGF0ZW1lbnQgPSBzKCdUcnlTdGF0ZW1lbnQnLFxuXHRcdC8vIFRPRE86IEFzc2VydCBpbiBwb3N0Q29uc3RydWN0XG5cdFx0J0F0IGxlYXN0IG9uZSBvZiBgaGFuZGxlcmAgb3IgYGZpbmFsaXplcmAgbXVzdCBiZSBub24tbnVsbC4nLFxuXHRcdFtcblx0XHRcdCdibG9jaycsIEJsb2NrU3RhdGVtZW50LFxuXHRcdFx0J2hhbmRsZXInLCBOdWxsYWJsZShDYXRjaENsYXVzZSksXG5cdFx0XHQnZmluYWxpemVyJywgTnVsbGFibGUoQmxvY2tTdGF0ZW1lbnQpXG5cdFx0XSksXG5cdFdoaWxlU3RhdGVtZW50ID0gcygnV2hpbGVTdGF0ZW1lbnQnLFxuXHRcdCdgd2hpbGUgKHRlc3QpIGJvZHlgLicsXG5cdFx0W1xuXHRcdFx0J3Rlc3QnLCBFeHByZXNzaW9uLFxuXHRcdFx0J2JvZHknLCBTdGF0ZW1lbnRcblx0XHRdKSxcblx0RG9XaGlsZVN0YXRlbWVudCA9IHMoJ0RvV2hpbGVTdGF0ZW1lbnQnLFxuXHRcdC8vIFRPRE86IE5vdGUgdGhhdCBib2R5IG5lZWRzIGJyYWNlcyFcblx0XHQnYGRvIHsgYm9keSB9IHdoaWxlICh0ZXN0KWAuJyxcblx0XHRbXG5cdFx0XHQnYm9keScsIFN0YXRlbWVudCxcblx0XHRcdCd0ZXN0JywgRXhwcmVzc2lvblxuXHRcdF0pLFxuXHRGb3JTdGF0ZW1lbnQgPSBzKCdGb3JTdGF0ZW1lbnQnLFxuXHRcdGBcblx0XHRcdFxcYGZvciAoaW5pdDsgdGVzdDsgdXBkYXRlKSBib2R5XFxgLlxuXHRcdFx0Tm90IHRvIGJlIGNvbmZ1c2VkIHdpdGggRm9ySW5TdGF0ZW1lbnQgb3IgRm9yT2ZTdGF0ZW1lbnQuYCxcblx0XHRbXG5cdFx0XHQnaW5pdCcsIE51bGxhYmxlKFVuaW9uKFZhcmlhYmxlRGVjbGFyYXRpb24sIEV4cHJlc3Npb24pKSxcblx0XHRcdCd0ZXN0JywgTnVsbGFibGUoRXhwcmVzc2lvbiksXG5cdFx0XHQndXBkYXRlJywgTnVsbGFibGUoRXhwcmVzc2lvbiksXG5cdFx0XHQnYm9keScsIFN0YXRlbWVudFxuXHRcdF0pLFxuXHRGb3JJblN0YXRlbWVudCA9IHMoJ0ZvckluU3RhdGVtZW50Jyxcblx0XHQnYGZvciAobGVmdCBpbiByaWdodCkgYm9keWAuJyxcblx0XHRbXG5cdFx0XHQnbGVmdCcsIFVuaW9uKFZhcmlhYmxlRGVjbGFyYXRpb24sIEV4cHJlc3Npb24pLFxuXHRcdFx0J3JpZ2h0JywgRXhwcmVzc2lvbixcblx0XHRcdCdib2R5JywgU3RhdGVtZW50XG5cdFx0XSksXG5cdEZvck9mU3RhdGVtZW50ID0gcygnRm9yT2ZTdGF0ZW1lbnQnLFxuXHRcdCdgZm9yIChsZWZ0IG9mIHJpZ2h0KSBib2R5YC4nLFxuXHRcdFtcblx0XHRcdCdsZWZ0JywgVW5pb24oVmFyaWFibGVEZWNsYXJhdGlvbiwgRXhwcmVzc2lvbiksXG5cdFx0XHQncmlnaHQnLCBFeHByZXNzaW9uLFxuXHRcdFx0J2JvZHknLCBTdGF0ZW1lbnRcblx0XHRdKSxcblx0RGVidWdnZXJTdGF0ZW1lbnQgPSBzKCdEZWJ1Z2dlclN0YXRlbWVudCcsXG5cdFx0J1RoZSBgZGVidWdnZXJgIGtleXdvcmQuJyxcblx0XHRbIF0pLFxuXG5cdC8vIERlY2xhcmF0aW9uc1xuXHRGdW5jdGlvbiA9IGFic3RyYWN0KCdGdW5jdGlvbicsIE5vZGUsICdGdW5jdGlvbkRlY2xhcmF0aW9uIG9yIEZ1bmN0aW9uRXhwcmVzc2lvbi4nKSxcblx0Ly8gVE9ETzogRnVuY3Rpb24gdG9vXG5cdEZ1bmN0aW9uRGVjbGFyYXRpb24gPSBkKCdGdW5jdGlvbkRlY2xhcmF0aW9uJyxcblx0XHQnVW5saWtlIGZvciBGdW5jdGlvbkV4cHJlc3Npb24sIGlkIG11c3Qgbm90IGJlIG51bGwuJyxcblx0XHRbXG5cdFx0XHQnaWQnLCBJZGVudGlmaWVyLFxuXHRcdFx0J3BhcmFtcycsIFtJZGVudGlmaWVyXSxcblx0XHRcdCdib2R5JywgQmxvY2tTdGF0ZW1lbnQsXG5cdFx0XHQnZ2VuZXJhdG9yJywgQm9vbGVhblxuXHRcdF0pLFxuXG5cdFZhcmlhYmxlRGVjbGFyYXRvciA9IG4oJ1ZhcmlhYmxlRGVjbGFyYXRvcicsXG5cdFx0J0Egc2luZ2xlIHZhcmlhYmxlIHdpdGhpbiBhIFZhcmlhYmxlRGVjbGFyYXRpb24uJyxcblx0XHRbXG5cdFx0XHQnaWQnLCBQYXR0ZXJuLFxuXHRcdFx0J2luaXQnLCBOdWxsYWJsZShFeHByZXNzaW9uKVxuXHRcdF0pLFxuXHRWYXJpYWJsZURlY2xhcmF0aW9uS2luZCA9IG5ld1NldChbICdjb25zdCcsICdsZXQnLCAndmFyJyBdKSxcblx0VmFyaWFibGVEZWNsYXJhdGlvbiA9IGQoJ1ZhcmlhYmxlRGVjbGFyYXRpb24nLFxuXHRcdC8vIFRPRE86IEFzc2VydFxuXHRcdGBcblx0XHRcdERlY2xhcmVzIGFuZCBvcHRpb25hbGx5IGluaXRpYWxpemVzIG1hbnkgdmFyaWFibGVzLlxuXHRcdFx0TXVzdCBiZSBhdCBsZWFzdCBvbmUgZGVjbGFyYXRpb24uYCxcblx0XHRbXG5cdFx0XHQna2luZCcsIFZhcmlhYmxlRGVjbGFyYXRpb25LaW5kLFxuXHRcdFx0J2RlY2xhcmF0aW9ucycsIFtWYXJpYWJsZURlY2xhcmF0b3JdXG5cdFx0XSksXG5cblx0Ly8gRXhwcmVzc2lvbnNcblx0VGhpc0V4cHJlc3Npb24gPSBlKCdUaGlzRXhwcmVzc2lvbicsXG5cdFx0J1RoZSBgdGhpc2Aga2V5d29yZC4nLFxuXHRcdFsgXSksXG5cdEFycmF5RXhwcmVzc2lvbiA9IGUoJ0FycmF5RXhwcmVzc2lvbicsXG5cdFx0J0FuIGFycmF5IGxpdGVyYWwuJyxcblx0XHRbICdlbGVtZW50cycsIFtOdWxsYWJsZShFeHByZXNzaW9uKV0gXSksXG5cdFByb3BlcnR5S2luZCA9IG5ld1NldChbICdpbml0JywgJ2dldCcsICdzZXQnIF0pLFxuXHRQcm9wZXJ0eSA9IG4oJ1Byb3BlcnR5Jyxcblx0XHQvLyBUT0RPOkFTU0VSVFxuXHRcdGBcblx0XHRcdFBhcnQgb2YgYW4gT2JqZWN0RXhwcmVzc2lvbi5cblx0XHRcdElmIGtpbmQgaXMgJ2dldCcgb3IgJ3NldCcsIHRoZW4gdmFsdWUgc2hvdWxkIGJlIGEgRnVuY3Rpb25FeHByZXNzaW9uLmAsXG5cdFx0W1xuXHRcdFx0J2tpbmQnLCBQcm9wZXJ0eUtpbmQsXG5cdFx0XHQvLyBUT0RPOiBMaXRlcmFsU3RyaW5nIHwgTGl0ZXJhbE51bWJlclxuXHRcdFx0J2tleScsIFVuaW9uKExpdGVyYWwsIElkZW50aWZpZXIpLFxuXHRcdFx0J3ZhbHVlJywgRXhwcmVzc2lvblxuXHRcdF0pLFxuXHRPYmplY3RFeHByZXNzaW9uID0gZSgnT2JqZWN0RXhwcmVzc2lvbicsXG5cdFx0J0FuIG9iamVjdCBsaXRlcmFsLicsXG5cdFx0WyAncHJvcGVydGllcycsIFtQcm9wZXJ0eV0gXSksXG5cdC8vIFRPRE86IEluaGVyaXRzIGZyb20gRnVuY3Rpb25cblx0RnVuY3Rpb25FeHByZXNzaW9uID0gZSgnRnVuY3Rpb25FeHByZXNzaW9uJyxcblx0XHRgXG5cdFx0XHRcXGBmdW5jdGlvbiBpZChwYXJhbXMpIGJvZHlcXGAgb3IgXFxgZnVuY3Rpb24qIGlkKHBhcmFtcykgYm9keVxcYC5cblx0XHRcdEZ1bmN0aW9uIGluIGFuIGV4cHJlc3Npb24gcG9zaXRpb24uXG5cdFx0XHRUbyBkZWNsYXJlIGEgZnVuY3Rpb24sIHVzZSBGdW5jdGlvbkRlY2xhcmF0aW9uLCBub3QgRXhwcmVzc2lvblN0YXRlbWVudC5cblx0XHRcdFNlZSBhbHNvIFxcYGVzYXN0LnV0aWwgdGh1bmtcXGAgYW5kIEFycm93RnVuY3Rpb25FeHByZXNzaW9uLmAsXG5cdFx0W1xuXHRcdFx0J2lkJywgTnVsbGFibGUoSWRlbnRpZmllciksXG5cdFx0XHQncGFyYW1zJywgW1BhdHRlcm5dLFxuXHRcdFx0J2JvZHknLCBCbG9ja1N0YXRlbWVudCxcblx0XHRcdCdnZW5lcmF0b3InLCBCb29sZWFuXG5cdFx0XSxcblx0XHR7XG5cdFx0XHRwb3N0Q29uc3RydWN0KCkge1xuXHRcdFx0XHR0aGlzLmdlbmVyYXRvciA9IEJvb2xlYW4odGhpcy5nZW5lcmF0b3IpXG5cdFx0XHR9XG5cdFx0fSksXG5cdC8vIFRPRE86IEluaGVyaXRzIGZyb20gRnVuY3Rpb25cblx0QXJyb3dGdW5jdGlvbkV4cHJlc3Npb24gPSBlKCdBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbicsXG5cdFx0J0xpa2UgRnVuY3Rpb25FeHByZXNzaW9uIGJ1dCB1c2VzIHRoZSBgcGFyYW1zID0+IGJvZHlgIGZvcm0uJyxcblx0XHRbXG5cdFx0XHQncGFyYW1zJywgW1BhdHRlcm5dLFxuXHRcdFx0J2JvZHknLCBVbmlvbihCbG9ja1N0YXRlbWVudCwgRXhwcmVzc2lvbilcblx0XHRdKSxcblx0U2VxdWVuY2VFeHByZXNzaW9uID0gZSgnU2VxdWVuY2VFeHByZXNzaW9uJyxcblx0XHRgXG5cdFx0XHRcXGBleHByZXNzaW9uc1swXSwgZXhwcmVzc2lvbnNbMV0sIC4uLlxcYC5cblx0XHRcdEV4cHJlc3Npb24gY29tcG9zZWQgb2Ygb3RoZXIgZXhwcmVzc2lvbnMsIHNlcGFyYXRlZCBieSB0aGUgY29tbWEgb3BlcmF0b3IuXG5cdFx0XHQqTm90KiBmb3IgcGFyYW1ldGVyIGxpc3RzLmAsXG5cdFx0WyAnZXhwcmVzc2lvbnMnLCBbIEV4cHJlc3Npb24gXSBdKSxcblx0Ly8gVE9ETzogdGVzdCBgLSBuZXcgWGAuIFByb2JhYmx5IG5lZWQgcGFyZW5zIGFyb3VuZCBhcmd1bWVudC5cblx0VW5hcnlPcGVyYXRvciA9IG5ld1NldChbICctJywgJysnLCAnIScsICd+JywgJ3R5cGVvZicsICd2b2lkJywgJ2RlbGV0ZScgXSksXG5cdFVuYXJ5RXhwcmVzc2lvbiA9IGUoJ1VuYXJ5RXhwcmVzc2lvbicsXG5cdFx0J2BvcGVyYXRvciBhcmd1bWVudGAuIENhbGxzIGEgdW5hcnkgb3BlcmF0b3IuJyxcblx0XHRbXG5cdFx0XHQnb3BlcmF0b3InLCBVbmFyeU9wZXJhdG9yLFxuXHRcdFx0J2FyZ3VtZW50JywgRXhwcmVzc2lvblxuXHRcdF0pLFxuXHRCaW5hcnlPcGVyYXRvciA9IG5ld1NldChbXG5cdFx0Jz09JywgJyE9JywgJz09PScsICchPT0nLFxuXHRcdCc8JywgJzw9JywgJz4nLCAnPj0nLFxuXHRcdCc8PCcsICc+PicsICc+Pj4nLFxuXHRcdCcrJywgJy0nLCAnKicsICcvJywgJyUnLFxuXHRcdCd8JywgJ14nLCAnJicsICdpbicsXG5cdFx0J2luc3RhbmNlb2YnXSksXG5cdC8vIFRPRE86IFJlbmRlciB3aXRoIHBhcmVuc1xuXHRCaW5hcnlFeHByZXNzaW9uID0gZSgnQmluYXJ5RXhwcmVzc2lvbicsXG5cdFx0J2BsZWZ0IG9wZXJhdG9yIHJpZ2h0YC4gQ2FsbHMgYSBiaW5hcnkgb3BlcmF0b3IuJyxcblx0XHRbXG5cdFx0XHQnb3BlcmF0b3InLCBCaW5hcnlPcGVyYXRvcixcblx0XHRcdCdsZWZ0JywgRXhwcmVzc2lvbixcblx0XHRcdCdyaWdodCcsIEV4cHJlc3Npb25cblx0XHRdKSxcblx0QXNzaWdubWVudE9wZXJhdG9yID0gbmV3U2V0KFtcblx0XHQnPScsICcrPScsICctPScsICcqPScsICcvPScsICclPScsXG5cdFx0Jzw8PScsICc+Pj0nLCAnPj4+PScsXG5cdFx0J3w9JywgJ149JywgJyY9J1xuXHRdKSxcblx0QXNzaWdubWVudEV4cHJlc3Npb24gPSBlKCdBc3NpZ25tZW50RXhwcmVzc2lvbicsXG5cdFx0YFxuXHRcdFx0XFxgbGVmdCBvcGVyYXRvciByaWdodFxcYC5cblx0XHRcdE11dGF0ZXMgYW4gZXhpc3RpbmcgdmFyaWFibGUuXG5cdFx0XHREbyBub3QgY29uZnVzZSB3aXRoIFZhcmlhYmxlRGVjbGFyYXRpb24uYCxcblx0XHRbXG5cdFx0XHQnb3BlcmF0b3InLCBBc3NpZ25tZW50T3BlcmF0b3IsXG5cdFx0XHQnbGVmdCcsIFBhdHRlcm4sXG5cdFx0XHQncmlnaHQnLCBFeHByZXNzaW9uXG5cdFx0XSksXG5cdFVwZGF0ZU9wZXJhdG9yID0gbmV3U2V0KFsgJysrJywgJy0tJyBdKSxcblx0VXBkYXRlRXhwcmVzc2lvbiA9IGUoJ1VwZGF0ZUV4cHJlc3Npb24nLFxuXHRcdCdgKythcmd1bWVudGAgb3IgYGFyZ3VtZW50KytgLiBJbmNyZW1lbnRzIG9yIGRlY3JlbWVudHMgYSBudW1iZXIuJyxcblx0XHRbXG5cdFx0XHQnb3BlcmF0b3InLCBVcGRhdGVPcGVyYXRvcixcblx0XHRcdCdhcmd1bWVudCcsIEV4cHJlc3Npb24sXG5cdFx0XHQncHJlZml4JywgQm9vbGVhblxuXHRcdF0pLFxuXHRMb2dpY2FsT3BlcmF0b3IgPSBuZXdTZXQoWyAnfHwnLCAnJiYnIF0pLFxuXHRMb2dpY2FsRXhwcmVzc2lvbiA9IGUoJ0xvZ2ljYWxFeHByZXNzaW9uJyxcblx0XHQnYGxlZnQgb3BlcmF0b3IgcmlnaHRgLiBDYWxscyBhIGxhenkgbG9naWNhbCBvcGVyYXRvci4nLFxuXHRcdFtcblx0XHRcdCdvcGVyYXRvcicsIExvZ2ljYWxPcGVyYXRvcixcblx0XHRcdCdsZWZ0JywgRXhwcmVzc2lvbixcblx0XHRcdCdyaWdodCcsIEV4cHJlc3Npb25cblx0XHRdKSxcblx0Q29uZGl0aW9uYWxFeHByZXNzaW9uID0gZSgnQ29uZGl0aW9uYWxFeHByZXNzaW9uJyxcblx0XHQnYHRlc3QgPyBjb25zZXF1ZW50IDogYWx0ZXJuYXRlYC4nLFxuXHRcdFtcblx0XHRcdCd0ZXN0JywgRXhwcmVzc2lvbixcblx0XHRcdCdjb25zZXF1ZW50JywgRXhwcmVzc2lvbixcblx0XHRcdCdhbHRlcm5hdGUnLCBFeHByZXNzaW9uXG5cdFx0XSksXG5cdE5ld0V4cHJlc3Npb24gPSBlKCdOZXdFeHByZXNzaW9uJyxcblx0XHQnSnVzdCBsaWtlIENhbGxFeHByZXNzaW9uIGJ1dCB3aXRoIGBuZXdgIGluIGZyb250LicsXG5cdFx0W1xuXHRcdFx0J2NhbGxlZScsIEV4cHJlc3Npb24sXG5cdFx0XHQnYXJndW1lbnRzJywgW0V4cHJlc3Npb25dXG5cdFx0XSksXG5cdENhbGxFeHByZXNzaW9uID0gZSgnQ2FsbEV4cHJlc3Npb24nLFxuXHRcdCdgY2FsbGVlKGFyZ3VtZW50cylgLicsXG5cdFx0W1xuXHRcdFx0J2NhbGxlZScsIEV4cHJlc3Npb24sXG5cdFx0XHQnYXJndW1lbnRzJywgW0V4cHJlc3Npb25dXG5cdFx0XSksXG5cdE1lbWJlckV4cHJlc3Npb24gPSBlKCdNZW1iZXJFeHByZXNzaW9uJyxcblx0XHQvLyBUT0RPOkFTU0VSVFxuXHRcdGBcblx0XHRcdElmIGNvbXB1dGVkID09PSB0cnVlLCBcXGBvYmplY3RbcHJvcGVydHldXFxgLlxuXHRcdFx0RWxzZSwgXFxgb2JqZWN0LnByb3BlcnR5XFxgIC0tIG1lYW5pbmcgcHJvcGVydHkgc2hvdWxkIGJlIGFuIElkZW50aWZpZXIuYCxcblx0XHRbXG5cdFx0XHQnb2JqZWN0JywgRXhwcmVzc2lvbixcblx0XHRcdCdwcm9wZXJ0eScsIEV4cHJlc3Npb24sXG5cdFx0XHQnY29tcHV0ZWQnLCBCb29sZWFuXG5cdFx0XSksXG5cdFlpZWxkRXhwcmVzc2lvbiA9IGUoJ1lpZWxkRXhwcmVzc2lvbicsXG5cdFx0J2B5aWVsZCBhcmd1bWVudGAgb3IgYHlpZWxkKiBhcmd1bWVudGAuJyxcblx0XHRbXG5cdFx0XHQnYXJndW1lbnQnLCBFeHByZXNzaW9uLFxuXHRcdFx0J2RlbGVnYXRlJywgQm9vbGVhblxuXHRcdF0pLFxuXHQvLyBUT0RPOiBMaXRlcmFsIGFzIGFic3RyYWN0IHR5cGVcblx0Ly8gVmFsdWU6IE51bWJlciB8IFN0cmluZyB8IG51bGwgfCBCb29sZWFuXG5cdExpdGVyYWwgPSBlKCdMaXRlcmFsJyxcblx0XHQnQSBsaXRlcmFsIHRva2VuLicsXG5cdFx0WyAndmFsdWUnLCBPYmplY3QgXSksXG5cblx0Ly8gVGVtcGxhdGVzXG5cdC8vIFRPRE86IHRlc3QsIGRvY3VtZW50XG5cdFRlbXBsYXRlRWxlbWVudCA9IG4oJ1RlbXBsYXRlRWxlbWVudCcsXG5cdFx0J2RvYycsXG5cdFx0W1xuXHRcdFx0J3RhaWwnLCBCb29sZWFuLFxuXHRcdFx0Ly8gVE9ETzplc3RyZWUgc3BlYyBzYXlzIHsgY29va2VkLCB2YWx1ZSB9LCBidXQgYWNvcm4gdXNlcyB7IGNvb2tlZCwgcmF3IH1cblx0XHRcdC8vIFRPRE86IHsgY29va2VkOlN0cmluZywgcmF3OlN0cmluZyB9IGRhdGEgc3RydWN0dXJlXG5cdFx0XHQndmFsdWUnLCBPYmplY3Rcblx0XHRdKSxcblx0VGVtcGxhdGVMaXRlcmFsID0gZSgnVGVtcGxhdGVMaXRlcmFsJyxcblx0XHQnZG9jJyxcblx0XHRbXG5cdFx0XHQncXVhc2lzJywgW1RlbXBsYXRlRWxlbWVudF0sXG5cdFx0XHQnZXhwcmVzc2lvbnMnLCBbRXhwcmVzc2lvbl1cblx0XHRdKSxcblx0VGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uID0gZSgnVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uJyxcblx0XHQnZG9jJyxcblx0XHRbXG5cdFx0XHQndGFnJywgRXhwcmVzc2lvbixcblx0XHRcdCdxdWFzaScsIFRlbXBsYXRlTGl0ZXJhbFxuXHRcdF0pLFxuXG5cdC8vIFBhdHRlcm5zXG5cdEFzc2lnbm1lbnRQcm9wZXJ0eSA9IG1ha2VUeXBlKFByb3BlcnR5KSgnQXNzaWdubWVudFByb3BlcnR5Jyxcblx0XHRgXG5cdFx0XHRKdXN0IGxpa2UgYSBQcm9wZXJ0eSwgYnV0IGtpbmQgaXMgYWx3YXlzIFxcYGluaXRcXGAuXG5cdFx0XHRBbHRob3VnaCB0ZWNobmljYWxseSBpdHMgb3duIHR5cGUsIFxcYF8udHlwZVxcYCB3aWxsIGJlICdQcm9wZXJ0eScuYCxcblx0XHRbICdrZXknLCBJZGVudGlmaWVyLCAndmFsdWUnLCBQYXR0ZXJuIF0sXG5cdFx0e1xuXHRcdFx0dHlwZTogJ1Byb3BlcnR5Jyxcblx0XHRcdG1ldGhvZDogZmFsc2UsXG5cdFx0XHRwb3N0Q29uc3RydWN0KCkge1xuXHRcdFx0XHRpZiAodGhpcy52YWx1ZSA9PT0gbnVsbClcblx0XHRcdFx0XHR0aGlzLnZhbHVlID0gdGhpcy5rZXlcblx0XHRcdFx0dGhpcy5raW5kID0gJ2luaXQnXG5cdFx0XHR9XG5cdFx0fSksXG5cdE9iamVjdFBhdHRlcm4gPSBwKCdPYmplY3RQYXR0ZXJuJyxcblx0XHQnYHsgYSwgYjogYyB9ID0gLi4uYC4gT2JqZWN0IGRlY29uc3RydWN0aW5nIHBhdHRlcm4uJyxcblx0XHRbICdwcm9wZXJ0aWVzJywgW0Fzc2lnbm1lbnRQcm9wZXJ0eV0gXSksXG5cdEFycmF5UGF0dGVybiA9IHAoJ0FycmF5UGF0dGVybicsXG5cdFx0J2BbIGEsIGIgXSA9IC4uLmAuIEFycmF5IGRlY29uc3RydWN0aW5nIHBhdHRlcm4uJyxcblx0XHRbICdlbGVtZW50cycsIFtOdWxsYWJsZShQYXR0ZXJuKV0gXSksXG5cdFJlc3RFbGVtZW50ID0gcCgnUmVzdEVsZW1lbnQnLFxuXHRcdC8vIFRPRE86VEVTVFxuXHRcdGBcblx0XHRcdENhbiBiZSB0aGUgbGFzdCBhcmd1bWVudCB0byBhIEZ1bmN0aW9uRXhwcmVzc2lvbi9GdW5jdGlvbkRlY2xhcmF0aW9uXG5cdFx0XHRvciAgZ28gYXQgdGhlIGVuZCBvZiBhbiBBcnJheVBhdHRlcm4uYCxcblx0XHRbICdhcmd1bWVudCcsIFBhdHRlcm4gXSksXG5cdC8vIFRPRE86IFdoYXQgaXMgdGhpcz9cblx0Ly8gQXNzaWdubWVudFBhdHRlcm4gPSBwKCdBc3NpZ25tZW50UGF0dGVybicsXG5cdC8vXHQnbGVmdCcsIFBhdHRlcm4sXG5cdC8vXHQncmlnaHQnLCBQYXR0ZXJuKSxcblxuXHRNZXRob2REZWZpbml0aW9uS2luZCA9IG5ld1NldChbICdjb25zdHJ1Y3RvcicsICdtZXRob2QnLCAnZ2V0JywgJ3NldCcgXSksXG5cdE1ldGhvZERlZmluaXRpb24gPSBuKCdNZXRob2REZWZpbml0aW9uJyxcblx0XHQvLyBUT0RPOkFzc2VydFxuXHRcdC8vIFRPRE86IHV0aWwgbWV0aG9kIGZvciBjb25zdHJ1Y3Rvci5cblx0XHRgXG5cdFx0XHRQYXJ0IG9mIGEgQ2xhc3NCb2R5LlxuXHRcdFx0SWYga2luZCBpcyAnY29uc3RydWN0b3InLCBrZXkgbXVzdCBiZSBJZGVudGlmaWVyKCdjb25zdHJ1Y3RvcicpLmAsXG5cdFx0W1xuXHRcdFx0J2tleScsIFVuaW9uKElkZW50aWZpZXIsIExpdGVyYWwpLFxuXHRcdFx0J3ZhbHVlJywgRnVuY3Rpb25FeHByZXNzaW9uLFxuXHRcdFx0J2tpbmQnLCBNZXRob2REZWZpbml0aW9uS2luZCxcblx0XHRcdCdzdGF0aWMnLCBCb29sZWFuLFxuXHRcdFx0J2NvbXB1dGVkJywgQm9vbGVhblxuXHRcdF0pLFxuXHRDbGFzc0JvZHkgPSBuKCdDbGFzc0JvZHknLFxuXHRcdCdDb250ZW50cyBvZiBhIENsYXNzLicsXG5cdFx0WyAnYm9keScsIFtNZXRob2REZWZpbml0aW9uXSBdKSxcblx0Q2xhc3MgPSBhYnN0cmFjdCgnQ2xhc3MnLCBOb2RlLFxuXHRcdCdDbGFzc0RlY2xhcmF0aW9uIG9yIENsYXNzRXhwcmVzc2lvbi4nKSxcblx0Ly8gVE9ETzogZXh0ZW5kcyBEZWNsYXJhdGlvbiB0b29cblx0Q2xhc3NEZWNsYXJhdGlvbiA9IG1ha2VUeXBlKENsYXNzKSgnQ2xhc3NEZWNsYXJhdGlvbicsXG5cdFx0J0NsYXNzIGluIGRlY2xhcmF0aW9uIHBvc2l0aW9uLicsXG5cdFx0W1xuXHRcdFx0J2lkJywgSWRlbnRpZmllcixcblx0XHRcdCdzdXBlckNsYXNzJywgTnVsbGFibGUoRXhwcmVzc2lvbiksXG5cdFx0XHQnYm9keScsIENsYXNzQm9keVxuXHRcdF0pLFxuXHRDbGFzc0V4cHJlc3Npb24gPSBtYWtlVHlwZShDbGFzcykoJ0NsYXNzRXhwcmVzc2lvbicsXG5cdFx0Ly8gVE9ETzogVGVzdCBjbGFzcyB3aXRoIG5vIHN1cGVyQ2xhc3Ncblx0XHQnQ2xhc3MgaW4gZXhwcmVzc2lvbiBwb3NpdGlvbi4nLFxuXHRcdFtcblx0XHRcdCdpZCcsIE51bGxhYmxlKElkZW50aWZpZXIpLFxuXHRcdFx0J3N1cGVyQ2xhc3MnLCBOdWxsYWJsZShFeHByZXNzaW9uKSxcblx0XHRcdCdib2R5JywgQ2xhc3NCb2R5XG5cdFx0XSksXG5cblx0TW9kdWxlU3BlY2lmaWVyID0gYWJzdHJhY3QoJ01vZHVsZVNwZWNpZmllcicsIE5vZGUsXG5cdFx0J0Egc3BlY2lmaWVyIGluIGFuIGltcG9ydCBvciBleHBvcnQgZGVjbGFyYXRpb24uJyksXG5cblx0SW1wb3J0U3BlY2lmaWVyQWJzdHJhY3QgPSBhYnN0cmFjdCgnSW1wb3J0U3BlY2lmaWVyQWJzdHJhY3QnLCBOb2RlLFxuXHRcdCdJbXBvcnRTcGVjaWZpZXIsIEltcG9ydERlZmF1bHRTcGVjaWZpZXIsIG9yIEltcG9ydE5hbWVzcGFjZVNwZWNpZmllci4nKSxcblx0SW1wb3J0RGVjbGFyYXRpb24gPSBuKCdJbXBvcnREZWNsYXJhdGlvbicsXG5cdFx0Ly8gVE9ETzpBU1NFUlRcblx0XHRgXG5cdFx0XHRcXGBpbXBvcnQgc3BlY2lmaWVycyBmcm9tIHNvdXJjZVxcYC5cblx0XHRcdE9ubHkgb25lIHNwZWNpZmllciBtYXkgYmUgYSBJbXBvcnREZWZhdWx0U3BlY2lmaWVyLlxuXHRcdFx0SWYgdGhlcmUgaXMgYW4gSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyLCBpdCBtdXN0IGJlIHRoZSBvbmx5IHNwZWNpZmllci5gLFxuXHRcdFtcblx0XHRcdCdzcGVjaWZpZXJzJywgW0ltcG9ydFNwZWNpZmllckFic3RyYWN0XSxcblx0XHRcdC8vIFRPRE86IExpdGVyYWxTdHJpbmdcblx0XHRcdCdzb3VyY2UnLCBMaXRlcmFsXG5cdFx0XSksXG5cdEltcG9ydFNwZWNpZmllciA9IG1ha2VUeXBlKE1vZHVsZVNwZWNpZmllcikoJ0ltcG9ydFNwZWNpZmllcicsXG5cdFx0YFxuXHRcdFx0QSBub24tZGVmYXVsdCBpbXBvcnQuIFVzZWQgaW4gYW4gSW1wb3J0RGVjbGFyYXRpb24uXG5cdFx0XHRGb3IgXFxgaW1wb3J0IHsgYSB9IGZyb20gXCJzb3VyY2VcIlxcYCwganVzdCBwYXNzIG9uZSBhcmd1bWVudCBhbmQgbG9jYWwgd2lsbCA9IGltcG9ydGVkLlxuXHRcdFx0Rm9yIFxcYGltcG9ydCB7IGEgYXMgYiB9IGZyb20gXCJzb3VyY2VcIlxcYCwgbWFrZSBpbXBvcnRlZCBcXGBhXFxgIGFuZCBsb2NhbCBcXGBiXFxgLmAsXG5cdFx0W1xuXHRcdFx0J2ltcG9ydGVkJywgSWRlbnRpZmllcixcblx0XHRcdCdsb2NhbCcsIElkZW50aWZpZXJcblx0XHRdLFxuXHRcdHtcblx0XHRcdHBvc3RDb25zdHJ1Y3QoKSB7XG5cdFx0XHRcdGlmICh0aGlzLmxvY2FsID09PSBudWxsKVxuXHRcdFx0XHRcdHRoaXMubG9jYWwgPSB0aGlzLmltcG9ydGVkXG5cdFx0XHR9XG5cdFx0fSksXG5cdEltcG9ydERlZmF1bHRTcGVjaWZpZXIgPSBtYWtlVHlwZShJbXBvcnRTcGVjaWZpZXJBYnN0cmFjdCkoJ0ltcG9ydERlZmF1bHRTcGVjaWZpZXInLFxuXHRcdCdUaGUgZGVmYXVsdCBleHBvcnQsIGFzIGluIGBpbXBvcnQgYSBmcm9tIFwic291cmNlXCJgLicsXG5cdFx0WyAnbG9jYWwnLCBJZGVudGlmaWVyIF0pLFxuXHRJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIgPSBtYWtlVHlwZShJbXBvcnRTcGVjaWZpZXJBYnN0cmFjdCkoJ0ltcG9ydE5hbWVzcGFjZVNwZWNpZmllcicsXG5cdFx0J09iamVjdCBvZiBldmVyeSBleHBvcnQsIGFzIGluIGBpbXBvcnQgKiBhcyBhIGZyb20gXCJzb3VyY2VcImAuJyxcblx0XHRbICdsb2NhbCcsIElkZW50aWZpZXIgXSksXG5cblx0RXhwb3J0U3BlY2lmaWVyID0gXHRtYWtlVHlwZShNb2R1bGVTcGVjaWZpZXIpKCdFeHBvcnRTcGVjaWZpZXInLFxuXHRcdGBcblx0XHRcdEEgbm9uLWRlZmF1bHQgZXhwb3J0LiBVc2VkIGluIGFuIEV4cG9ydE5hbWVkRGVjbGFyYXRpb24uXG5cdFx0XHRGb3IgXFxgZXhwb3J0IHsgYSB9IGZyb20gXCJzb3VyY2VcIlxcYCwganVzdCBwYXNzIG9uZSBhcmd1bWVudCBsb2NhbCB3aWxsID0gZXhwb3J0ZWQuXG5cdFx0XHRGb3IgXFxgZXhwb3J0IHsgYSBhcyBiIH1cXGAsIG1ha2UgZXhwb3J0ZWQgXFxgYlxcYCBhbmQgbG9jYWwgXFxgYVxcYC5gLFxuXHRcdFtcblx0XHRcdCdleHBvcnRlZCcsIElkZW50aWZpZXIsXG5cdFx0XHQnbG9jYWwnLCBJZGVudGlmaWVyXG5cdFx0XSxcblx0XHR7XG5cdFx0XHRwb3N0Q29uc3RydWN0KCkge1xuXHRcdFx0XHRpZiAodGhpcy5sb2NhbCA9PT0gbnVsbClcblx0XHRcdFx0XHR0aGlzLmxvY2FsID0gdGhpcy5leHBvcnRlZFxuXHRcdFx0fVxuXHRcdH0pLFxuXHRFeHBvcnROYW1lZERlY2xhcmF0aW9uID0gbignRXhwb3J0TmFtZWREZWNsYXJhdGlvbicsXG5cdFx0YFxuXHRcdFx0RXhwb3J0cyBtdWx0aXBsZSB2YWx1ZXMgYXMgaW4gXFxgZXhwb3J0IHsgYSwgYiBhcyBjIH1cXGAuXG5cdFx0XHRJZiBzb3VyY2UgIT09IG51bGwsXG5cdFx0XHRyZS1leHBvcnRzIGZyb20gdGhhdCBtb2R1bGUgYXMgaW4gXFxgZXhwb3J0IHsgLi4uIH0gZnJvbSBcInNvdXJjZVwiXFxgLmAsXG5cdFx0W1xuXHRcdFx0J2RlY2xhcmF0aW9uJywgTnVsbGFibGUoRGVjbGFyYXRpb24pLFxuXHRcdFx0J3NwZWNpZmllcnMnLCBbRXhwb3J0U3BlY2lmaWVyXSxcblx0XHRcdC8vIFRPRE86IExpdGVyYWxTdHJpbmdcblx0XHRcdCdzb3VyY2UnLCBOdWxsYWJsZShMaXRlcmFsKVxuXHRcdF0pLFxuXHRFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24gPSBuKCdFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24nLFxuXHRcdCdgZXhwb3J0IGRlZmF1bHQgZGVjbGFyYXRpb25gLicsXG5cdFx0W1xuXHRcdFx0J2RlY2xhcmF0aW9uJywgVW5pb24oRGVjbGFyYXRpb24sIEV4cHJlc3Npb24pXG5cdFx0XSksXG5cdEV4cG9ydEFsbERlY2xhcmF0aW9uID0gbignRXhwb3J0QWxsRGVjbGFyYXRpb24nLFxuXHRcdCdgZXhwb3J0ICogZnJvbSBzb3VyY2VgLicsXG5cdFx0Ly8gVE9ETzpMaXRlcmFsU3RyaW5nXG5cdFx0WyAnc291cmNlJywgTGl0ZXJhbCBdKVxuIl0sInNvdXJjZVJvb3QiOiIvc3JjIn0=