{"version":3,"sources":["specialize.js"],"names":[],"mappings":"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","file":"specialize.js","sourcesContent":["import { AssignmentExpression, BinaryExpression, BlockStatement, CallExpression, Expression,\n\tFunctionExpression, Identifier, Literal, MemberExpression, Pattern, Property, ReturnStatement,\n\tStatement, SwitchCase, SwitchStatement, YieldExpression, UnaryExpression, VariableDeclaration,\n\tVariableDeclarator, WhileStatement } from './ast'\nimport tuple from './private/tuple'\nimport { assert } from './private/util'\n\nconst s = (superType, namesTypes, protoProps) => tuple(\n\t`${superType.name}Specialization`,\n\tsuperType,\n\t`specialization of ${superType}`,\n\tnamesTypes,\n\tprotoProps)\n\nconst\n\tFunctionExpressionPlain = s(FunctionExpression,\n\t\t[ 'params', [Identifier], 'body', BlockStatement ], { id: null, generator: false }),\n\tFunctionExpressionPlainGenerator = s(FunctionExpression,\n\t\t[ 'params', [Identifier], 'body', BlockStatement ], { id: null, generator: true }),\n\tFunctionExpressionThunk = s(FunctionExpression, [ 'body', BlockStatement ], {\n\t\tid: null,\n\t\tparams: [],\n\t\tgenerator: false\n\t}),\n\tFunctionExpressionThunkGenerator = s(FunctionExpression, [ 'body', BlockStatement ], {\n\t\tid: null,\n\t\tparams: [],\n\t\tgenerator: true\n\t}),\n\tPropertyInit = s(Property, [ 'key', Expression, 'value', Expression ], { kind: 'init' }),\n\tPropertyGet = s(Property, [ 'key', Expression, 'value', Expression ], { kind: 'get' }),\n\tMemberExpressionComputed = s(MemberExpression,\n\t\t[ 'object', Expression, 'property', Expression ], { computed: true }),\n\tMemberExpressionIdentifier = s(MemberExpression,\n\t\t[ 'object', Expression, 'property', Literal ], { computed: false })\n\nconst LitTrue = Literal(true)\n\nexport const\n\tassignmentExpressionPlain = s(AssignmentExpression,\n\t\t[ 'left', Pattern, 'right', Expression ], { operator: '=' }),\n\tcallExpressionThunk = s(CallExpression,\n\t\t[ 'callee', Expression ], { arguments: [] }),\n\tfunctionExpressionPlain = (params, body, generator) =>\n\t\t(generator ? FunctionExpressionPlainGenerator : FunctionExpressionPlain)(params, body),\n\tfunctionExpressionThunk = (body, generator) =>\n\t\t(generator ? FunctionExpressionThunkGenerator : FunctionExpressionThunk)(body),\n\tvariableDeclarationConst =\n\t\ts(VariableDeclaration, [ 'declarations', [VariableDeclarator] ], { kind: 'const' }),\n\tunaryExpressionNegate =\n\t\ts(UnaryExpression, [ 'argument', Expression ], { operator: '-' }),\n\tswitchStatementOnTrue = s(SwitchStatement, [ 'cases', [SwitchCase] ], {\n\t\tdiscriminant: LitTrue,\n\t\t// May contain nested variable declarations\n\t\tlexical: true\n\t}),\n\twhileStatementInfinite = s(WhileStatement, [ 'body', Statement ], { test: LitTrue }),\n\tbinaryExpressionPlus = s(BinaryExpression,\n\t\t[ 'left', Expression, 'right', Expression ], { operator: '+' }),\n\tproperty = (kind, key, value) => {\n\t\tif (kind === 'init')\n\t\t\treturn PropertyInit(key, value)\n\t\telse {\n\t\t\tassert(kind === 'get')\n\t\t\treturn PropertyGet(key, value)\n\t\t}\n\t},\n\tmemberExpression = (object, property) =>\n\t\tproperty.type === 'Identifier' ?\n\t\t\tMemberExpressionIdentifier(object, property) :\n\t\t\tMemberExpressionComputed(object, property),\n\tyieldExpressionNoDelegate = s(YieldExpression, [ 'argument', Expression ], { delegate: false }),\n\tyieldExpressionDelegate = s(YieldExpression, [ 'argument', Expression ], { delegate: true })\n"],"sourceRoot":"/src"}